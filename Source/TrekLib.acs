#library "TrekLib"

global int 4:RedAlert, 7:FlightSpeed[], 9:ActorPosX[], 10:ActorPosY[], 13:Cutscene;
global str 5:LogEntry[], 6:Weapon[], 8:HealRate[];

#include "zcommon.acs"
#include "functions.acs"
#include "radar.acs"
#include "lift.acs"
#include "objectives.acs"

int ReloadCount;
int MapViewDelay;
int PlayerX, PlayerY, PlayerAngle;
int Flight;

int SkipCutscene = False;

int mapRadius = 80;
//int mapX = 425; //Tricorder screen overlay coords
//int mapY = 650;
//int mapX = 900; //Bottom right corner
//int mapY = 644;
//int mapX = 124; //Bottom left corner
//int mapY = 600;
//int mapX = 900; //Top right corner
//int mapY = 124;
int mapX = 124; //Top left corner
int mapY = 124;

int mapZoom = 10; 
int maxMapZoom = 16;

//int ScanRange = 4096;
int ScanRange = 8192;

int intStress = 2; 
// Proposed levels:
//   SickBay = 0
//   Quarters, Pool, etc. = 1
//   Shipboard = 2
//   Ashore = 3
//   Injured out of combat = 4
//   Injured in combat = 5
int intMaxStress = 5;
int intHealTimer = 35;

int bAutoHeal = 1;

/*
int ActiveMapMsgCountStart = 4096;
int ActiveMapMsgCount;

int MapActive = 0;
int MapArray[2048][2048][2]; //Width, Height, Seen/Color
int MapDiffArray[2048][2048]; //Width, Height
int MapMoversArray[2048][2048][2]; //Width, Height, Color/Time
*/

int numTitles = 16;
str TitleSequence[16][6] = {
	//Camera, 		Angle, 		Graphic, 		Graphic Hold Time, Delay, Activation TID, 
	{	1	, 	0	, 	""		, 	0.0	, 	35 * 9 + 17	, 	3	}, // First Pass - S 8s - 8 "...frontier"
	{	1	, 	0.2	, 	""		, 	0.0	, 	35 * 2	, 	4	}, // Reverse Angle - S 11s - 3
	{	8	, 	0	, 	""		, 	0.0	, 	35 * 1	, 	5	}, // Toward Planet - S 13s - 2
	{	6	, 	0	, 	""		, 	0.0	, 	35 * 3	, 	0	}, // In front of Planet - S 16s - 3 "Enterprise..."
	{	7	, 	0	, 	""		, 	0.0	, 	35 * 7 + 16	, 	0	}, // Reverse on Planet - S 24s - 8
	{	1	, 	0.25	, 	""		, 	0.0	, 	35 * 3	, 	0	}, // Title - C 27s - 3
	{	1	, 	0.25	, 	""		, 	0.0	, 	35 * 2	, 	3	}, // Title - S 29s - 2
	{	1	, 	0.25	, 	"Credits1"	, 	4.0	, 	35 * 1	, 	0	}, // Title - G 30s, shift at 33s - 1
	{	1	, 	0.25	, 	"Credits2"	, 	4.0	, 	35 * 5	, 	0	}, // Rodenberry - G 35s - 5
	{	1	, 	0.25	, 	""		, 	0.0	, 	35 * 4	, 	9	}, // Shatner - S 37s - 2
	{	1	, 	0.25	, 	"Credits3"	, 	4.0	, 	35 * 3	, 	0	}, // Shatner - G 40s - 3
	{	1	, 	0.25	, 	""		, 	0.0	, 	35 * 4	, 	3	}, // Nimoy - S 45s - 5
	{	1	, 	0.25	, 	"Credits4"	, 	4.0	, 	35 * 2	, 	0	}, // Nimoy - G 47s - 2
	{	1	, 	0.25	, 	""		, 	0.0	, 	35 * 4	, 	9	}, // Kelley - S 51s - 4
	{	1	, 	0.25	, 	"Credits5"	, 	4.0	, 	35 * 2	, 	0	}, // Kelley - G 54s - 3
	{	1	, 	0	, 	""		, 	0.0	, 	35 * 3 + 15	, 	0	}  // Delay before loop (and time delay until music is killed on first pass)
};

Script "W_LevelStart" ENTER
{
	Thing_ChangeTID(0, 1001+PlayerNumber());
	TakeInventory("HideHUD", 1);

	If (GameType() == GAME_TITLE_MAP || StrICmp(StrParam(n:PRINTNAME_LEVEL), "TitleMap") == 0)
	{
		GiveInventory("HideHUD", 1);

		SetHudSize(320, 200, 1);
		SetFont("WSMASK");
		HudMessage (s:"A"; 0, 0, -1, 160.0, 100.0, 0);

		ChangeCamera(1, 1, 1);
		SetCameraToTexture(1, "TITLECAM", 90);

		SetHudSize(1280, 960, 1);
		SetFont("TITLECAM");
		HudMessage (s:"A"; 0, 2, -1, 640.0, 480.0, 0);

		int showplanet = 0;
		bool shuttle = 0;

		Delay(35);

		If (GameType() != GAME_TITLE_MAP)
			SetMusic("music/opening.ogg", 0);

		While (TRUE)
		{
			For (int t = 0; t < numTitles; t++)
			{
				int oldCamera;
				int Camera = TitleSequence[t][0];
				int Angle = TitleSequence[t][1];
				str strGraphic = StrParam(s:TitleSequence[t][2]);
				int HoldTime = TitleSequence[t][3];
				int actionDelay = TitleSequence[t][4];
				int TID = TitleSequence[t][5];

				If (oldCamera && Camera != oldCamera && actionDelay >= 35)
				{
					Delay(actionDelay - 17);
					SetCameraToTexture(oldCamera, "TITLEALT", 90);
					FadeToGraphic ("TITLEALT", 0.0, 0.4, 0.8);
					Delay(17);
				}
				Else
				{
					If (HoldTime > 0)
						Delay(actionDelay - (0.5 * 35 / 1.0)); //Graphic transitions have built-in delays, so account for those in wait time
					Else
						Delay(actionDelay);
				}

				ChangeCamera(Camera, 1, 1);
				SetCameraToTexture(Camera, "TITLECAM", 90);

				If (t == numTitles - 1) SetMusic("*", 0);

				If (Angle != 0) SetActorAngle(Camera, Angle);

				If (strGraphic != "" && showPlanet == 0 && GameType() != GAME_TITLE_MAP)
				{
					int intTimeIn, intTimeHold, intTimeOut;
					int intEndHeight, intStartScale, intSteps, intStartHeight, intSizeStep, intAlpha, intHeight, intWidth;
					int s;

					intTimeIn = 0.5;

					If (t == 8)
					{ //Scale the old graphic and move it up
						intEndHeight = 1227;
						intStartScale = 0.626; //Height of 768 relative to the final size 

						intSteps = intTimeIn * 35 / 1.0;
						intStartHeight = intEndHeight * intStartScale / 1.0;
						intSizeStep = (intStartHeight - intEndHeight) / intSteps;

						For (s = 0; s <= intSteps; s++)
						{
							intHeight = intStartHeight - (s * intSizeStep);
							intWidth = intHeight * (4.0 / 3) / 1.0;
							SetHudSize(intWidth, intHeight, 1);
							HudMessage (s:"A"; HUDMSG_LAYER_OVERHUD, 1, -1, (intWidth / 2 + (-74 * s / intSteps)) * 1.0, (intHeight / 2 + (-171 * s / intSteps)) * 1.0, 0);
							Delay(1);
						}
						HudMessage (s:"A"; HUDMSG_FADEINOUT | HUDMSG_LAYER_OVERHUD, 0, -1, (intWidth / 2 - 74) * 1.0, (intHeight / 2 - 171) * 1.0, 1.0, 0.0, 0.5); //Draw as layer 0 so there's no fade in/out of the main logo

						SetHudSize(1024, 768, 0);
						intHeight = 768;
						intWidth = 1024;
					}

					SetFont(strGraphic);

					if (t != 8)
					{
						intEndHeight = 768;
						intStartScale = 0;

						intSteps = intTimeIn * 35 / 1.0;
						intStartHeight = intEndHeight * intStartScale / 1.0;
						intSizeStep = (intStartHeight - intEndHeight) / intSteps;

						For (s = 0; s <= intSteps; s++)
						{
							intHeight = intStartHeight - (s * intSizeStep);
							intWidth = intHeight * (4.0 / 3) / 1.0;
							intAlpha = s * 1.0 / intSteps;
							SetHudSize(intWidth, intHeight, 1);
							HudMessage (s:"A"; HUDMSG_LAYER_OVERHUD | HUDMSG_ALPHA, 1, -1, intWidth / 2 * 1.0, intHeight / 2 * 1.0, 0, intAlpha);
							Delay(1);
						}
						intTimeIn = 0;
					}

					if (t == 7) HoldTime = 10.0;

					HudMessage (s:"A"; HUDMSG_FADEINOUT | HUDMSG_LAYER_OVERHUD, 1, -1, intWidth / 2 * 1.0, intHeight / 2 * 1.0, HoldTime, intTimeIn, 0.5);
				}

				If (TID > 0)
				{
					Thing_Activate(TID);

					If (Camera == oldCamera || oldCamera == 0)
					{
						SetActorProperty(2, APROP_RenderStyle, Style_Translucent);
						For (int i = 0.0; i <= 1.0; i += 0.1)
						{
							SetActorProperty(2, APROP_Alpha, i);	
							Delay(1);
						}
						SetActorProperty(2, APROP_RenderStyle, Style_Normal);
					}
				}

				oldCamera = Camera;
			}

			Switch (showplanet % 3)
			{
				Case 2:
					SetActorState(20, "Spawn");
				break;
				Case 1:
					SetActorState(20, "Shuttle");
				break;
				Case 0:
					SetActorState(20, "Station");
				break;
			}

			shuttle = !shuttle;

			If (shuttle)
			{
				SetActorState(2, "Shuttle");
			}
			Else
			{
				SetActorState(2, "Spawn");
			}

			showplanet++;

			if (GameType() != GAME_TITLE_MAP)
				ChangeLevel ("MAP09", 0, CHANGELEVEL_NOINTERMISSION | CHANGELEVEL_PRERAISEWEAPON, -1);
		}
	}
	Else
	{
		If (!GetCVar("gl_precache"))
			Notification("\crWarning!", "This mod contains textures that cause game lag when not pre-cached.\nPlease enable \cl'Precache GL Textures'\cc in the OpenGL Texture Options Menu.", "Alternatively, you can set the \cl'gl_precache'\cc CVAR to \cltrue\cc in the console.", 1);

		CheckEnterEffect();
/*
		LogEntry[PlayerNumber() * 10] = ""; //No objective is set at this time.
		LogEntry[PlayerNumber() * 10 + 1] = ""; //No objective is set at this time.
		LogEntry[PlayerNumber() * 10 + 2] = ""; //No objective is set at this time.
		LogEntry[PlayerNumber() * 10 + 3] = ""; //No objective is set at this time.
		LogEntry[PlayerNumber() * 10 + 4] = ""; //No objective is set at this time.
*/
		If (StrICmp(StrParam(n:PRINTNAME_LEVEL), "Planet") == 0)
		{
			//Thing_Activate(5);
			Scroll_Floor(14, 1, 1, 0); //Scrolling fog/clouds effect
		}

		If (StrICmp(StrParam(n:PRINTNAME_LEVEL), "Ship") == 0)
		{
			GiveInventory("AccessLevel1", 1);
			SetCameraToTexture(553, "CAMTEX_1", 85);
			SetCameraToTexture(6, "CAMTEX_2", 85);
		}

		ACS_NamedExecuteAlways("RedAlert", 0, RedAlert);
	}
}

Function void CheckEnterEffect (void)
{
	If (GetUserVariable(0, "user_travel") > 0)
	{
		If (GetUserVariable(0, "user_travel") == 1)
		{
			FadeToGraphic("Gold", 1.0, 0, 0); //Cover up the level transition
			GiveInventory("Transport", 1);
		}
		Else If (GetUserVariable(0, "user_travel") == 2)
		{
			ActivatorSound("turbolift/end", 128);
		}


		Letterbox(0);
		SetUserVariable(0, "user_travel", 0);
		SetActorProperty(0, APROP_INVULNERABLE, 0);
		SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);

		RedAlert = 0;
	}
}

Script "W_LevelReturn" RETURN
{
	CheckEnterEffect();

	Delay(35);
	ACS_NamedExecuteAlways("RedAlert", 0, RedAlert);
}

Script "W_RadarZoomIn" (void)
{
	mapZoom++;
	If (mapZoom >= maxMapZoom) mapZoom = maxMapZoom - 1;
}

Script "W_RadarZoomOut" (void)
{
	mapZoom--;
	If (mapZoom < 1) mapZoom = 1;
}

Script "W_PlayerLoop" ENTER
{
	If (CheckInventory("Charge") < GetAmmoCapacity("Charge") && CheckInventory("PhaserType1"))
	{
		If (ReloadCount == 8)
		{
			GiveInventory("Charge", 1);
			ReloadCount = 0;
		}
		Else
			ReloadCount++;
	}

	If (CheckInventory("Tricorder") && !Cutscene)
	{
		int scale = 0;
		int hud = 1;

		int HUDX = GetScreenWidth();
		int HUDY = GetScreenHeight();

		SetHudSize(HUDX, HUDY, 1);

		If(StrIcmp(GetWeapon(), "Tricorder") == 0)
		{
			ACS_NamedExecute("PrintScan", 0, 0);
		}
		Else
		{
			HudMessage(s:""; 0, 1003, 0, 0, 0, 0);
			HudMessage(s:""; 0, 1002, 0, 0, 0, 0);
			HudMessage(s:""; 0, 1001, 0, 0, 0, 0);

			ACS_NamedExecute("PrintScan", 0, 1);
		}

		scale = maxMapZoom - mapZoom;

		DrawRadar(0, scale, mapX, mapY, mapRadius * scale, hud);
	}
	Else
	{
		DrawRadar(0, 0, 0, 0, 0, 0);
	}

	If (!Flight && !Cutscene)
	{
		DoMovement();

		If (GetPlayerInput(-1, INPUT_BUTTONS) & BT_USER1)
			ACS_NamedExecute("Lean", 0, -750);
		Else If (GetPlayerInput(-1, INPUT_BUTTONS) & BT_USER2)
			ACS_NamedExecute("Lean", 0, 750);		
		Else
		{
			ACS_NamedExecute("Lean", 0, 0);
			SetSideLean();
		}
	}

	int intHealth = GetActorProperty(0, APROP_Health);

	If (bAutoHeal && intHealth < 100)
	{
		intHealTimer--;

		If (intHealTimer <= 0)
		{		
			int intHealRate = intMaxStress - intStress;
			HealRate[PlayerNumber()] = intHealRate;
			int intHealModRate = 35;

			If(intHealth > 0)
			{
				GiveInventory("Health", 1);
				intHealModRate = 100 * intHealModRate / intHealth;
			}
			intHealTimer = intHealModRate + (14 * intStress);

			If (intHealTimer > 350) intHealTimer = 350;
		}
	}

	If (GetUserVariable(0, "user_travel") == 1)
	{
		SetWeapon("NoWeapon");
	}
	Else
	{
		If (StrICmp(GetWeapon(), "TOSCommunicator") == 0)
		{
			//Let it go...
		}
		Else If (StrICmp(GetWeapon(), "NoWeapon") != 0)
			Weapon[PlayerNumber()] = GetWeapon();
		Else
		{
			Delay(70);
			SetWeapon(Weapon[PlayerNumber()]);
		}
	}

	If (Cutscene && (GetPlayerInput(-1, INPUT_BUTTONS) != GetPlayerInput(-1, INPUT_OLDBUTTONS)))
	{
		SkipCutscene = True;
	}

	Delay(1);
	Restart;
}

Script "SetStress" (int intInput)
{
	intStress = intInput;
}

int intLeanCount;

Function int SetSideLean(void)
{
	int intAmt, intDir, intCurRoll, intCurDir, intSpeed, intMaxLean;

	intSpeed = VectorLength(GetActorVelX(0), GetActorVelY(0));

	intMaxLean = intSpeed / 1.0 * 40;

	intCurRoll = GetActorRoll(0);

	If (intCurRoll < 0.5)
		intCurDir = 1;
	Else If (intCurRoll > 0.5)
		intCurDir = -1;

	If (GetPlayerInput(-1, INPUT_SIDEMOVE))
		If (intLeanCount < intMaxLean) intLeanCount += 20;

	If ((GetPlayerInput(-1, INPUT_SIDEMOVE) > 0))
		intDir = 1;
	Else If ((GetPlayerInput(-1, INPUT_SIDEMOVE) < 0))
		intDir = -1;

	If (intDir == 0 || intLeanCount > intMaxLean)
	{
		If (intLeanCount > 0)
			intLeanCount = intLeanCount - 40;
		Else
			intLeanCount = 0;
	}

	If (intDir != 0 && intLeanCount <= intMaxLean)
		intAmt = intDir * intLeanCount;
	Else
	{
		If (intCurDir > 0)
			intAmt = intLeanCount;
		Else If (intCurDir < 0)
			intAmt = -intLeanCount;
		Else
			intAmt = 0;
	}

	return ChangeActorRoll(0, intAmt, TRUE);
}

str strState = "";
int Active = 0;

Function int DoMovement (void)
{
	If (GetActorProperty(0, APROP_Health) <= 0) return 0;

	int intX, intY, intZ, intSpeed, intVelZ, intForward, intTurn, intCrouch;
		
	intX = GetActorVelX(0);
	intY = GetActorVelY(0);
	intZ = GetActorVelZ(0);

	intSpeed = FixedMul(intX, intX) + FixedMul(intY, intY) + FixedMul(intZ, intZ);

	intForward = GetPlayerInput(-1, MODINPUT_FORWARDMOVE);
	intTurn = GetPlayerInput(-1, MODINPUT_BUTTONS) & (BT_LEFT | BT_RIGHT);
	intCrouch = GetActorProperty(0, APROP_Height) < 64.0;

	intVelZ = intZ >> 16;

	str strStateModifier = "";
	str strWeaponClass = "";
	str strOldState = strState;

	str strWeapon = GetWeapon();

	If (	StrICmp(strWeapon, "PhaserType1") == 0 ||
		StrICmp(strWeapon, "PhaserType2") == 0 ||
		StrICmp(strWeapon, "Disruptor") == 0)
	{
		SetUserVariable(0, "user_weaponclass", 1);
	}
	Else If (StrICmp(strWeapon, "PhotonGrenadeLauncher") == 0)
	{
		strWeaponClass = "2";
		SetUserVariable(0, "user_weaponclass", 3);
	}
	Else
	{
		strWeaponClass = "2";
		SetUserVariable(0, "user_weaponclass", 2);
	}

	If (intCrouch) strStateModifier = "Crouch.";
	SetUserVariable(0, "user_crouch", intCrouch);

	If (GetActorProperty(0, APROP_Waterlevel) >= 2) strStateModifier = "Swim.";

	If (intVelZ != 0)
	{
		If (GetUserVariable(0, "user_climb"))
		{
			If (intVelZ >= 0)
				strState = "Climb.Up";
			Else
				strState = "Climb.Down";
		}
		Else If (abs(intVelZ) > 6)
			strState = "Jump";
	}
	Else If (intSpeed != 0)
	{
		If (intForward < 0)
			strState = strParam(s:strStateModifier, s:"Walk.Back");
		Else If (intForward >= 0)
		{
			If (intSpeed > 42.0)
				strState = strParam(s:strStateModifier, s:"Run", s:strWeaponClass);
			Else
				strState = strParam(s:strStateModifier, s:"Walk", s:strWeaponClass);
		}
	}
	Else
	{
		If (intTurn)
			strState = strParam(s:"Turn", s:strWeaponClass);
		Else
			strState = strParam(s:"Stand", s:strWeaponClass);
//			strState = "Spawn";

		strState = strParam(s:strStateModifier, s:strState);
	}

/*
	//Handle hiding the model when changing position via portals...  Cleans up the single-player experience, at least...
	If (abs(ActorPosX[PlayerNumber()] - GetActorX(0)) > 400.0 || abs(ActorPosY[PlayerNumber()] - GetActorY(0)) > 400.0)
	{
		If (PlayerCount() > 1) 
			strState = "Hidden";
	}
*/

	//Only change the state if it needs to change...
	If (((StrICmp(strState, strOldState) != 0) && !GetUserVariable(0, "user_active")) || GetUserVariable(0, "user_forcestatechange"))
	{
		SetActorState(0, strState);
	}
/*
	If ((intForward < -1) &&
		!GetUserVariable(0, "user_back") &&
		!GetUserVariable(0, "user_active"))
	{
		SetActorState(0, "WalkBack");
		SetUserVariable(0, "user_back", 1);
		SetUserVariable(0, "user_spawn", 0);
	}
	Else If ((!intForward && intTurn) && 
		!GetUserVariable(0, "user_back") &&
		!GetUserVariable(0, "user_active"))
	{
		SetActorState(0, "Turn");
		SetUserVariable(0, "user_back", 0);
		SetUserVariable(0, "user_spawn", 0);
	}
	Else If ((intForward > 1) &&
		(intSpeed > 21.0) &&
		!GetUserVariable(0, "user_back") &&
		!GetUserVariable(0, "user_active"))
	{
		SetActorState(0, "Run");
		SetUserVariable(0, "user_back", 1);
		SetUserVariable(0, "user_spawn", 0);
	}
	Else If ((intForward > 1) &&
		!GetUserVariable(0, "user_back") &&
		!GetUserVariable(0, "user_active"))
	{
		SetActorState(0, "Walk");
		SetUserVariable(0, "user_back", 1);
		SetUserVariable(0, "user_spawn", 0);
	}
	Else If (intSpeed == 0 && !intTurn && !GetUserVariable(0, "user_active") && !GetUserVariable(0, "user_spawn"))
	{
		SetActorState(0, "Spawn");
		SetUserVariable(0, "user_back", 0);
		SetUserVariable(0, "user_spawn", 1);
	}

	If (!GetUserVariable(0, "user_active"))
	{
		If (intVelZ != 0)
		{
			If (GetUserVariable(0, "user_climb"))
				SetActorState(0, "Climb");
			Else
				SetActorState(0, "Jump");
			SetUserVariable(0, "user_active", 1);
		}
		Else If (intVelZ < 0)
		{
			If (GetUserVariable(0, "user_climb"))
				SetActorState(0, "Climb");
			Else
				SetActorState(0, "Jump.Loop");
			SetUserVariable(0, "user_active", 1);
		}
	}

	If (GetActorProperty(0, APROP_Waterlevel) >= 2 && !GetUserVariable(0, "user_active"))
	{
		SetActorState(0, "Swim");
		SetUserVariable(0, "user_active", 1);
	}

	If (GetActorProperty(0, APROP_Height) < 64.0 && !GetUserVariable(0, "user_active"))
	{
		SetActorState(0, "Crouch");
		SetUserVariable(0, "user_crouch", 1);
		SetUserVariable(0, "user_active", 1);
	}
	Else If (GetActorProperty(0, APROP_Height) >= 64.0)
	{
		SetUserVariable(0, "user_crouch", 0);
	}
*/
	If (intVelZ == 0)
	{
		SetActorVelocity(0, GetActorVelX(0) * 8 / 10, GetActorVelY(0) * 8 / 10, 0, 0, 1);

		//Decrease speed with lower health
	 	int intNewSpeed = 1.0 + (GetActorProperty(0, APROP_Health) * 0.5 / 100);

		//Increase speed with stress level/adrenaline
		If (intStress > 0)
			intNewSpeed += (intStress * intNewSpeed / 4) / intMaxStress;

		If (intNewSpeed > 1.9) intNewSpeed = 1.9;
		SetActorProperty(0, APROP_Speed, intNewSpeed);
	}
	Else
		SetActorProperty(0, APROP_Speed, 1.0);

	ActorPosX[PlayerNumber()] = GetActorX(0);
	ActorPosY[PlayerNumber()] = GetActorY(0);

	return 1;
}

Script "Lean" (int intDir)
{
	If (GameType() == GAME_TITLE_MAP || StrICmp(StrParam(n:PRINTNAME_LEVEL), "TitleMap") == 0) Terminate;

	int camTID = 90000 + PlayerNumber();
	int PlayerTID = 1001 + PlayerNumber();

	int intHeightOffset;

	If (intDir == 0)
	{
		ChangeCamera(0, 0, 1);
		Thing_Remove(camTID);
		Terminate;
	}

/*
	If (GetActorProperty(PlayerTID, APROP_Height) < GetActorProperty(PlayerTID, APROP_ViewHeight))
		intHeightOffset = GetActorProperty(PlayerTID, APROP_ViewHeight) / 2;
	Else
*/
	intHeightOffset = GetActorProperty(PlayerTID, APROP_Height);

	If (intHeightOffset < 64.0) intHeightOffset += 20.0;

	Spawn("LeanCam", 0, 0, 0, camTID, GetActorAngle(0) >> 8);
	SetUserVariable(camTID, "user_ZHeight", intHeightOffset / 1.0);

	SetActivator (camTID);
	SetPointer (AAPTR_MASTER, PlayerTID);

	ChangeCamera(camTID, 0, 1);
	SetActorPitch(camTID, GetActorPitch(PlayerTID));

	If (intDir > 0)
		SetActorState(camTID, "Right");
	Else If (intDir < 0)
		SetActorState(camTID, "Left");

	ChangeActorRoll(camTID, intDir, TRUE);
}

Script "A_Disintegrate" (int intColor, int bNoDeathJump)
{
	If (ActivatorTID() == 0) Thing_ChangeTID(0, UniqueTID());

	If (CheckInventory("Health") <= 0 && !GetActorProperty(0, APROP_Invulnerable))
	{
		If (CheckFlag(0, "ISMONSTER"))
			PlaySound(0, "effects/disintegrate/alive", CHAN_AUTO, 0.35);
		Else
		{
			If (GetActorProperty(ActivatorTID(), APROP_Radius) >= 16)
				PlaySound(0, "effects/disintegrate/object", CHAN_AUTO, 0.35);
			Else
				PlaySound(0, "effects/disintegrate/object_small", CHAN_AUTO, 0.35);
		}

		SetActorProperty(0, APROP_Invulnerable, 1);
		SetActorProperty(0, APROP_NoTarget, 1);
		SetActorProperty(0, APROP_StencilColor, intColor);
		SetActorProperty(0, APROP_Alpha, 1.0);
		SetActorProperty(0, APROP_RenderStyle, STYLE_TranslucentStencil);

		For (int d= 0; d <= 100; d = d + 5)
		{
			SetActorState(0, "Pain");
			SetActorProperty(0, APROP_Alpha, 1.0 - (d * 0.01));
			Delay (1);
		}

		If (!bNoDeathJump) SetActorState(0, "Death");
		Thing_Destroy(ActivatorTID());
	}
}

Script "A_Stun" (int time)
{
	int actor_health;

	If (ActivatorTID() == 0) Thing_ChangeTID(0, UniqueTID());

	If (!CheckFlag(ActivatorTID(), "ISMONSTER")) Terminate;

	actor_health = CheckInventory("Health");

	If (actor_health <= 50 && actor_health > 0)
	{
		If (time == 0) time = 10;

		SetActorState(0, "Death.Stun");

		Delay(35 * time);

		If (CheckInventory("Health") > 0)
		{
			Thing_Raise(ActivatorTID());
			SetActorProperty(0, APROP_Health, actor_health);
			If (!SetActorState(0, "Raise"))
			{
				SetActorState(0, "Spawn");
			}
		}
	}
}

Function void FadeToGraphic (str strImage, int holdTime, int inTime, int outTime)
{
	SetHudSize(1280, 960, 1);
	SetFont(strImage);
	HudMessage (s:"A"; HUDMSG_FADEINOUT | HUDMSG_LAYER_OVERHUD, 1, -1, 640.0, 480.0, holdTime, inTime, outTime);
}

Script "A_Transport" (int Fade, int BeamDir)
{
//	SetActivatorToTarget(0);

	SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
	SetActorProperty(0, APROP_INVULNERABLE, 1);
	SetActorProperty(0, APROP_RenderStyle, STYLE_Translucent);

	If (BeamDir != 1)
	{
		SpawnForced("TransporterEffect", GetActorX(0), GetActorY(0), GetActorZ(0), 0, 0);
		If (Fade && !Cutscene)
		{
			//FadeRange (250, 234, 149, 0.0, 250, 234, 149, 1.0, 6.0);
			FadeToGraphic ("Gold", 5.0, 4.0, 0);
		}
		SetActorProperty(0, APROP_Alpha, 1.0);

		For (int out = 100; out >= 0; out = out - 1)
		{
			SetActorProperty(0, APROP_Alpha, out * 0.01);
			Delay (2);
		}
	}

	If (BeamDir > 1) Delay(35);

	If (BeamDir > 0)
	{
		SpawnForced("TransporterEffect2", GetActorX(0), GetActorY(0), GetActorZ(0), 0, 0);
		If (Fade && !Cutscene)
		{
			//FadeRange (250, 234, 149, 1.0, 250, 234, 149, 0.0, 6.0);
			FadeToGraphic ("Gold", 1.0, 0, 3.0);
		}
		SetActorProperty(0, APROP_Alpha, 0);

		For (int in = 0; in <= 100; in = in + 1)
		{
			SetActorProperty(0, APROP_Alpha, in * 0.01);
			Delay (1);
		}
	}

	SetActorProperty(0, APROP_RenderStyle, STYLE_Normal);
	SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
	SetActorProperty(0, APROP_INVULNERABLE, 0);
}

Script "A_TransportK" (void)
{
	SetActorProperty(0, APROP_INVULNERABLE, 1);
	SetActorProperty(0, APROP_RenderStyle, STYLE_TranslucentStencil);

	SetActorProperty(0, APROP_Alpha, 0);
	SetActorProperty(0, APROP_StencilColor, "#bf0000");

	For (int in = 0; in <= 100; in = in + 1)
	{
		If (in >= 25) SetActorProperty(0, APROP_RenderStyle, STYLE_Translucent);
		SetActorProperty(0, APROP_Alpha, in * 0.01);
		Delay (1);
	}

	SetActorProperty(0, APROP_RenderStyle, STYLE_Normal);
	SetActorProperty(0, APROP_INVULNERABLE, 0);
}


Script "A_AmmoStation" (int intType, int intAmt)
{
	If (intAmt <= 0) Terminate;

	str strType, strWeapon;

	SetActivatorToTarget(0);

	Switch (intType)
	{
		Case 1:
			strWeapon = "PhaserRifle";
			strType = "RifleCharge";
		break;
		default:
			strWeapon = "Disruptor";
			strType = "DisruptorCharge";
		break;
	}

	SetUserVariable(0, "user_travel", 1); //Force weapon to lower
	Weapon[PlayerNumber()] = strWeapon; //Set current weapon to whatever the unit is dispensing

	If (CheckInventory(strWeapon))
	{
		int intNeededToMax = GetAmmoCapacity(strType) - CheckInventory(strType);

		If (intNeededToMax > 0)
		{
			int intModAmt = intNeededToMax % intAmt;

			If (intModAmt == 0) intModAmt = intAmt;

			GiveInventory(strType, intModAmt);
			SetResultValue(intModAmt);
		}
		Else
			SetResultValue(0);
		Delay(35);
	}
	Else
	{
		GiveInventory(strWeapon, 1);
		SetResultValue(-1);
	}

	SetUserVariable(0, "user_travel", 0); //Allow Weapon to Rais
	SetWeapon(strWeapon); //Force currently dispensed weapon, just in case
}

Script "ToggleFly" (int EnterExit, int minHeight, int maxHeight)
{
	If (PlayerNumber() < 0) Terminate;

	If (EnterExit)
	{
		SetPlayerProperty (0, 1, PROP_FLY);
		SetUserVariable(0, "user_climb", 1);

		If (minHeight != 0 && maxHeight != 0)
		{
			maxHeight = maxHeight - GetActorProperty(0, APROP_Height) / 2.0;
			minHeight = minHeight - GetActorProperty(0, APROP_Height) / 2.0;
			While (GetUserVariable(0, "user_climb") == 1)
			{
				If (GetActorZ(ActivatorTID()) <= maxHeight << 16 && GetActorZ(ActivatorTID()) >= minHeight << 16)
				{
					SetPlayerProperty (0, 1, PROP_FLY);
				}
				Else
				{
					SetPlayerProperty (0, 0, PROP_FLY);
				}
				Delay(1);
			}
		}
	}
	Else
	{
		SetPlayerProperty (0, 0, PROP_FLY);
		SetUserVariable(0, "user_climb", 0);
	}
}

Function int WolfCoord(int intCoord)
{
	int intOriginal = intCoord;
	int intReturn = 0;

	intCoord = intCoord / 64.0;

	intCoord = intCoord + 64;

	return intCoord;
}

Script "A_CheckFrightened" (void)
{
	int Afraid = (GetUserVariable(0, "user_Ammo") <= 0) || (GetActorProperty(0, APROP_Health) <= GetUserVariable(0, "user_Health") >> 1);

	If (Afraid)
	{
		If (CheckActorProperty(0, APROP_Frightened, 0))
		{
			SetActorProperty(0, APROP_Frightened, 1);
			SetActorProperty(0, APROP_Speed, (GetActorProperty(0, APROP_Speed) * 2));
			SetActorProperty(0, APROP_ReactionTime, 0x7fffffff);
		}
	}
	Else
	{
		If (CheckActorProperty(0, APROP_Frightened, 1))
		{
			SetActorProperty(0, APROP_Frightened, 0);
			SetActorProperty(0, APROP_Speed, (GetActorProperty(0, APROP_Speed) / 2));
			SetActorProperty(0, APROP_ReactionTime, 8);
		}
	}
}

Script "Intro" (void)
{
	SetHudsize(1024, 768, 1);
/*
	SetFont("STARFLD");
	HudMessage(s:"A"; HUDMSG_PLAIN, 200, CR_UNTRANSLATED, 0.5, 0.5, 0.0);
*/

	int warpfield = 1;

	int entx = 512;
	int enty = 384;

	int size = 1000;

	int baseid = 101;

	While (warpfield)
	{
/*
		entx = FixedMul (entx, 0.99);
		enty = FixedMul (enty, 0.99);

		int centx = entx * 2;
		int centy = enty * 2;

		SetHudsize(centx, centy, 1);
		SetFont("ENTFRNTA");
		HudMessage(s:"A"; HUDMSG_PLAIN, 99, CR_UNTRANSLATED, centx / 2 * 1.0, centy / 2 * 1.0, 0.0);

		If (entx <= 300) ACS_NamedExecute("ScalePlanet", 0, enty * 2);

		If (entx <= 256) warpfield = 0;
*/
		ACS_NamedExecuteAlways("ScaleStars", 0, baseid, size, 1);
		baseid++;
		If (baseid > 104 /*119*/)
		{
			baseid = 100;
		}
		Delay(20 /*5*/);
	}
/*
	SetHudsize(1280, 1024, 1);
	SetFont("Logo");
	HudMessage(s:"A"; HUDMSG_FADEINOUT, 97, CR_UNTRANSLATED, 640.0, 100.1, 0.0, 1.0, 0.0);
	SetFont("BIGFONT");
	HudMessage(s:"A Doom Total Conversion"; HUDMSG_FADEINOUT | HUDMSG_COLORSTRING, 96, "TOSMenuGold", 1180.2, 924.2, 0.0, 1.0, 0.0);
	Delay(35);
	SetFont("Logo");
	HudMessage(s:"A"; HUDMSG_PLAIN, 97, CR_UNTRANSLATED, 640.0, 100.1, 0.0);
	SetFont("BIGFONT");
	HudMessage(s:"A Doom Total Conversion"; HUDMSG_PLAIN | HUDMSG_COLORSTRING, 96, "TOSMenuGold", 1180.2, 924.2, 0.0);
*/
}

Script "ScaleStars" (int id, int size, int dir)
{
	int width, height, start;

	if (dir == 0) dir = 1;

	If (dir == -1)
	{
		width = 0;
		height = 0;
		start = size;
	}
	else
	{
		width = size * 4 / 3;
		height = size;
		start = 1;
	}

	str image = StrParam(s:"STARS",d:random(1,4));

	SetFont(image);

	int steps = size / 10;

	For (int i = 0; i <= steps; i++)
	{
		SetHudsize(width - (i * 4 / 3 * dir * 10), height - (i * dir * 10), 1);
		HudMessage(s:"A"; HUDMSG_PLAIN, id, CR_UNTRANSLATED, (width - (i * 4 / 3 * dir * 10)) / 2 * 1.0, (height - i * dir * 10) / 2 * 1.0, 0.0);
		delay(1);
	}
	HudMessage(s:""; 0, id, 0, 0, 0, 0);
}

Script "ScalePlanet" (int size)
{
	int planetoffset = 0;

	While (planetoffset <= 239)
	{
		SetHudsize(size * 4 / 3, size, 1);

		int planx = (size * 4 / 3) - (planetoffset * 4 / 3);
		int plany = size - planetoffset;
			
		SetFont("PLANET");
		HudMessage(s:"A"; HUDMSG_PLAIN, 98, CR_UNTRANSLATED, planx * 1.0 + 0.1, plany * 1.0 + 0.1, 0.0);

		planetoffset += 1;
		delay(1);
	}
}

Script "GetTargetTID" (void)
{
	SetActivator(0, AAPTR_PLAYER_GETTARGET);
	int TID = ActivatorTID();

	If (TID == 0 && StrICmp(GetActorClass(0), "None") != 0) 
	{
		TID = UniqueTID(20000);
		Thing_ChangeTID(0, TID);
	}

	SetResultValue (TID);
}

Script "PrintInfo" (void)
{
	int TID = ACS_NamedExecuteWithResult("GetTargetTID", 0);

	If (TID != 0)
	{
		int Height = GetActorProperty(TID, APROP_Height);
		int Radius = GetActorProperty(TID, APROP_Radius);

		int Mass = GetActorProperty(TID, APROP_Mass);

		int Health = GetActorProperty(TID, APROP_Health);
		int SpawnHealth = GetActorProperty(TID, APROP_SpawnHealth);
		int Friend = GetActorProperty(TID, APROP_Friendly);
		int Class = GetActorProperty(TID, APROP_NameTag);
/*
		If (!CheckFlag(TID, "SOLID"))
		{
			Height = Height / 1.0 * GetActorProperty(TID, APROP_ScaleY);
			Radius = Radius / 1.0 * GetActorProperty(TID, APROP_ScaleX);
		}
		Else
		{
*/
			If (GetUserVariable(TID, "user_height") > 0) Height = GetUserVariable(TID, "user_height") * 1.0;
			If (GetUserVariable(TID, "user_width") > 0) Radius = (GetUserVariable(TID, "user_width") / 2) * 1.0;
//		}

		If (StrICmp(Right(Class, 5), "Radar") == 0)
			Class = Left(Class, StrLen(Class) - 5);

		int x = GetActorX(tid) - GetActorX(0);
		int y = GetActorY(tid) - GetActorY(0); 

		int vang = VectorAngle(x,y);
		int ang = (vang - GetActorAngle(0) + 1.0) % 1.0;

		int dist = 0;
		if(((vang+0.125)%0.5) > 0.25) dist = FixedDiv(y, sin(vang));
		else dist = FixedDiv(x, cos(vang));

		If (Friend)
			Class = StrParam(s:"\c[TOSBrightGreen]", s:Class);
		Else If (CheckFlag(TID, "ISMONSTER"))
			Class = StrParam(s:"\c[TOSBrightRed]", s:Class);
		Else
			Class = StrParam(s:"\c[TOSBrightBlue]", s:Class);

		str Titles = StrParam(	s:"\n",
					s:"\c[TOSBrightWhite]", s:"Height:\n",
					s:"\c[TOSBrightWhite]", s:"Width:\n",
					s:"\c[TOSBrightWhite]", s:"Distance:\n"
					);

		str Data = StrParam(	s:"\n",
					s:"\c[TOSMenuLightGold]", s:Metric(Height, 3), s:"m\n",
					s:"\c[TOSMenuLightGold]", s:Metric(Radius * 2, 3), s:"m\n",
					s:"\c[TOSMenuLightGold]", s:Metric(dist / 3, 3), s:"m\n"
					);

		If (Mass < 999999)
		{
			Titles = StrParam(s:Titles, 
					s:"\n",
					s:"\c[TOSBrightWhite]", s:"Mass:\n"
					);

			Data = StrParam(s:Data, 
					s:"\n",
					s:"\c[TOSMenuLightGold]", d:FixedMul(Mass * 1.0, 0.85) / 1.0, s:"kg\n"
					);
		}

		If (!GetActorProperty(TID, APROP_Invulnerable))
		{
			Titles = StrParam(s:Titles, 
					s:"\c[TOSBrightWhite]", s:"Health:"
					);

			Data = StrParam(s:Data, 
					s:"\c[TOSMenuLightGold]", d:Health * 100 / SpawnHealth, s:"%"
					);
		}

		//HudMessageOnActor(TID, ScanRange, Data, Height / 2, Radius, "CONFONT");
/*
		int HUDX = 640 * 8;
		int HUDY = 400 * 8;
*/
		int HUDX = 640;
		int HUDY = 400;

		SetHudSize(HUDX, HUDY, 1);
		SetFont("SMALLFNT");
//		SetFont("ARI48");
		SetHudWrapWidth(HUDX / 5);
		//HudMessage(s:Data; HUDMSG_TYPEON, 1000, CR_UNTRANSLATED, (HUDX / 2 - HUDX / 6) * 1.0 + 0.1, (HUDY - (HUDY / 4)) * 1.0 + 0.1, 1.0, 0.02, 1.5);
		HudMessage(s:Class; HUDMSG_FADEINOUT, 1000, CR_UNTRANSLATED, (HUDX / 2 - HUDX / 7) * 1.0 + 0.1, (HUDY - (HUDY * 15 / 54)) * 1.0 + 0.1, 0.1, 0, 0.1);
		HudMessage(s:Titles; HUDMSG_FADEINOUT, 999, CR_UNTRANSLATED, (HUDX / 2 - HUDX / 7) * 1.0 + 0.1, (HUDY - (HUDY * 7 / 27)) * 1.0 + 0.1, 0.1, 0, 0.1);
		HudMessage(s:Data; HUDMSG_FADEINOUT, 998, CR_UNTRANSLATED, (HUDX / 2) * 1.0 + 0.2, (HUDY - (HUDY * 7 / 27)) * 1.0 + 0.1, 0.1, 0, 0.1);
	}
}

Script "PrintScan" (int filter)
{
	int TID = ACS_NamedExecuteWithResult("GetTargetTID", 0);

	If (TID != 0)
	{
		If (GetCVar("g_debug") > 0)
		{
			HudMessageOnActor(TID, ScanRange, GetActorClass(TID), 0, 0, "SUPBOLAA", 3);
		}

		int Height = GetActorProperty(TID, APROP_Height);
		int Radius = GetActorProperty(TID, APROP_Radius);
/*
		If (!CheckFlag(TID, "SOLID"))
		{
			Height = Height / 1.0 * GetActorProperty(TID, APROP_ScaleY);
			Radius = Radius / 1.0 * GetActorProperty(TID, APROP_ScaleX);
		}
		Else
		{
*/
			If (GetUserVariable(TID, "user_height") > 0) Height = GetUserVariable(TID, "user_height") * 1.0;
			If (GetUserVariable(TID, "user_width") > 0) Radius = (GetUserVariable(TID, "user_width") / 2) * 1.0;
//		}
		int SpawnHealth = GetActorProperty(TID, APROP_SpawnHealth);
		int Friend = GetActorProperty(TID, APROP_Friendly);
		int Class = GetActorProperty(TID, APROP_NameTag);

		If (CheckFlag(TID, "USESPECIAL") && GetUserVariable(TID, "user_uses") > 0)
		{
			If (Friend)
				Class = StrParam(s:"\c[TOSBrightGreen]", s:Class);
			Else If (CheckFlag(TID, "ISMONSTER"))
				Class = StrParam(s:"\c[TOSBrightRed]", s:Class);
			Else
				Class = StrParam(s:"\c[TOSBrightGold]", s:Class);

			HudMessageOnActor(TID, ScanRange, "A", Height, Radius, "ScanB", 1);

			HudMessageOnActor(TID, ScanRange, Class, Height, Radius, "SUPBOLAA", 2);
		}
		Else If (filter == 0)
		{
			If (Friend)
				HudMessageOnActor(TID, ScanRange, "A", Height, Radius, "Scan", 1);
			Else If (CheckFlag(TID, "ISMONSTER"))
				HudMessageOnActor(TID, ScanRange, "A", Height, Radius, "ScanA", 1);
			Else
				HudMessageOnActor(TID, ScanRange, "A", Height, Radius, "Scan", 1);
		}
	}
}

Function void HudMessageOnActor(int tid, int Range, str text, int Height, int Radius, str Font, int scale)
{
	int dist, ang, vang, pitch, x, y, multiplierX, multiplierY;
	int HUDX = 1024;
	int HUDY = 768;
	int ratio = 1.0;

	x = GetActorX(tid) - GetActorX(0);
	y = GetActorY(tid) - GetActorY(0); 

	vang = VectorAngle(x,y);
	ang = (vang - GetActorAngle(0) + 1.0) % 1.0;

	if(((vang+0.125)%0.5) > 0.25) dist = FixedDiv(y, sin(vang));
	else dist = FixedDiv(x, cos(vang));

	If (scale > 0)
	{
		HUDX = HUDX * scale;
		HUDY = HUDY * scale;

//		multiplierX = FixedMul(dist / Range, Radius);
//		multiplierY = FixedMul(dist / Range, Height / 2);
//		multiplierX = (dist - (Radius * 2 * 3)) / 1.0 + 32.0;
//		multiplierY = FixedMul(1.0 - (dist / Range), Height);
//		multiplierX = (dist - (Radius * 2 * 3)) / 1.0;
//		multiplierY = (dist - (Height * 2)) / 1.0;
//		multiplierX = Range * 1.0 / dist * Radius / 8;
//		multiplierY = Range * 1.0 / dist * (Height / 2) / 8;
//		multiplierX = 1.0 - (Range * Radius 	/ dist * 1.0);
//		multiplierY = 1.0 - (Range * Height 	/ dist * 0.5);
//		multiplierX = (Range * 1.0 / (dist - (Radius * 2 / 2))) * 1.0;
//		multiplierY = (Range * 1.0 / (dist - Height / 2)) * 1.0;

		If (dist / 1.0 < Range)
		{
			ratio = scale * (Range * 1.0 - dist) / Range;
//			multiplierX = ((Range * 1.0 - dist) / Range * 32) / 1.0;
			multiplierX = ratio * (((Range - dist / 1.0) + ((Radius / 1.0) * 512)) / (dist / 1.0));
			multiplierY = ratio * (((Range - dist / 1.0) + ((Height / 1.0) * 256)) / (dist / 1.0));
//			multiplierY = ratio * (((Range * 1.0 - dist) + Height * 256) / dist);
		}
		If (multiplierX < 24.0) multiplierX = 24.0;
		If (multiplierY < 24.0) multiplierY = 24.0;
	}
//	HUDX = HUDX + multiplierX;
//	HUDY = HUDY + multiplierY;

	SetHudSize(HUDX, HUDY, 1);

	if ((ang < 0.2 || ang > 0.8) && (dist >> 16 < Range/* && dist >> 16 > 64*/))
	{
		int Zdist = (GetActorZ(tid) + Height / 2) - (GetActorZ(0) + GetActorProperty(0, APROP_Height)); 
 /*
		If (!CheckFlag(TID, "SOLID"))
		{
			Zdist = Zdist - Height;
		}
*/
		pitch = VectorAngle(dist, Zdist);
		pitch = (pitch + GetActorPitch(0) + 1.0) % 1.0;

		if(getactorpitch(0) >= -16200 && getactorpitch(0) <= 16200)
		{
			x = HUDX/2 - ((HUDX/2) * sin(ang) / cos(ang));
			y = HUDY/2 - ((HUDX/2) * sin(pitch) / cos(pitch));
		}

		If (scale == 1)
		{
			SetFont(StrParam(s:Font,s:"_TL"));
			HudMessage(s:text; HUDMSG_LAYER_UNDERHUD | HUDMSG_NOTWITHFULLMAP, 1005, CR_UNTRANSLATED, (x << 16) - multiplierX, (y << 16) - multiplierY, 0.1);

			SetFont(StrParam(s:Font,s:"_TR"));
			HudMessage(s:text; HUDMSG_LAYER_UNDERHUD | HUDMSG_NOTWITHFULLMAP, 1006, CR_UNTRANSLATED, (x << 16) + multiplierX, (y << 16) - multiplierY, 0.1);

			SetFont(StrParam(s:Font,s:"_BL"));
			HudMessage(s:text; HUDMSG_LAYER_UNDERHUD | HUDMSG_NOTWITHFULLMAP, 1007, CR_UNTRANSLATED, (x << 16) - multiplierX, (y << 16) + multiplierY, 0.1);

			SetFont(StrParam(s:Font,s:"_BR"));
			HudMessage(s:text; HUDMSG_LAYER_UNDERHUD | HUDMSG_NOTWITHFULLMAP, 1008, CR_UNTRANSLATED, (x << 16) + multiplierX, (y << 16) + multiplierY, 0.1);
		}
		Else
		{
			SetFont(Font);
			HudMessage(s:text; HUDMSG_LAYER_UNDERHUD | HUDMSG_NOTWITHFULLMAP, 1007 + scale, CR_UNTRANSLATED, (x << 16), (y << 16) - multiplierY - 96.0, 0.1);
		}
	}
}

Script "OverheadCam" (void)
{
	int CamTID = 30000 + PlayerNumber();

	int x, y, z, oldZ, angle, fov;
	int offset = 32.0;
	int minZ = 90.0 + offset;
	int maxZ = 512.0;

	int maxFOV= 120;

	While (TRUE)
	{
		x = GetActorX(0);
		y = GetActorY(0);
		z = GetActorCeilingZ(0) - offset;
		angle = GetActorAngle(0);

		If (abs(oldZ - z) < offset) z = oldZ;

		If (z > GetActorZ(0) + maxZ) z = GetActorZ(0) + maxZ;
		If (z < GetActorZ(0) + minZ) z = GetActorZ(0) + minZ;

		fov = maxFOV - (maxFOV * Exp(2, mapZoom - 1) / 1.0); //(120 * FixedDiv(z, GetActorZ(0) + maxZ)) / 1.0;

		If (!ThingCountName ("ChaseCam", CamTID))
		{
			Spawn ("ChaseCam", x, y, 100.0, CamTID, angle >> 8);

			If (ThingCountName ("ChaseCam", CamTID))
			{
				int PlayerTID = 1001 + PlayerNumber();
				SetActorPitch (CamTID, 64 << 8);
				SetActivator (CamTID);
				SetPointer (AAPTR_MASTER, PlayerTID);
			}
		}
		Else
		{
			SetCameraToTexture(CamTID, "TRICHUDS", fov);
			SetActorAngle (CamTID, angle);
		}

		oldZ = z;

		Delay(1);
	}	
}

Script "Open3DPolyDoors" (int Num, int zMax, int Angle)
{
	If (GetActorZ(0) <= zMax)
		PolyObj_DoorSlide(Num, 16, Angle, 34, 105);	
}

Script "Open3DPolyDoor" (int Num, int zMax, int Angle)
{
	If (GetActorZ(0) <= zMax)
		PolyObj_DoorSlide(Num, 16, Angle, 49, 105);	
}


Script "RedAlert" (int OnOff)
{
	RedAlert = OnOff;
/*
	If (RedAlert > 0)
	{
		ReplaceTextures ("WALLALER", "WALLALE3");
		ReplaceTextures ("WALLALE2", "WALLALE4");
		ReplaceTextures ("ARCHALER", "ARCHALE2");
		ReplaceTextures ("TRANSALE", "TRANSAL2");
		ReplaceTextures ("BR_WALLP", "BR_WALLQ");
		ReplaceTextures ("BR_WALLL", "BR_WALLM");
		ReplaceTextures ("BR_WALLR", "BR_WALLU");
	}
	Else
	{
		ReplaceTextures ("WALLALE3", "WALLALER");
		ReplaceTextures ("WALLALE4", "WALLALE2");
		ReplaceTextures ("ARCHALE2", "ARCHALER");
		ReplaceTextures ("TRANSAL2", "TRANSALE");
		ReplaceTextures ("BR_WALLQ", "BR_WALLP");
		ReplaceTextures ("BR_WALLM", "BR_WALLL");
		ReplaceTextures ("BR_WALLU", "BR_WALLR");
	}
*/
	While (RedAlert > 0)
	{
//		AmbientSound("ambient/redalert", 63);
		PlaySound(0, "ambient/redalert", CHAN_7, 0.3);
		Delay(6 * 35 + 15);
	}
}

Script "CancelRedAlert" (void)
{
	ACS_NamedExecuteAlways("RedAlert", 0, 0);
}

int moves[5];

Script "A_CheckNavDir" (void)
{
	int intSpawnDist = 32.0;
	int intMaxMove = 64;
	int retValue = 0;

	int ActorX = GetActorX(0);
	int ActorY = GetActorY(0);
	int ActorZ = GetActorZ(0);
	int ActorA = GetActorAngle(0) >> 8;

	int ID = ActivatorTID();

	int originX, originY, destX, destY, moveX, moveY, intMoveDist, dir, dist;

	moveX = 0;
	moveY = 0;

	For (int a = 0; a < 256; a += 64)
	{
		intMoveDist = 0;
		moveX = 0;
		moveY = 0;

		Switch (a)
		{
			Case 0:
				moveX = 1;
			break;
			Case 64:
				moveY = 1;
			break;
			Case 128:
				moveX = -1;
			break;
			Case 192:
				moveY = -1;
			break;
		}

		originX = ActorX + 12.0 + (32.0 * moveX);
		originY = ActorY + 12.0 + (32.0 * moveY); 

		Spawn("Nav_Check", originX, originY, ActorZ + 32.0, 1900 + ID, 0);
	
		moves[(a / 64) + 1] = 0;

		For (int i = 1; i <= intMaxMove; i = i + 1)
		{
			destX = originX + (moveX * 32.0 * i) - (16.0 * moveX);
			destY = originY + (moveY * 32.0 * i) - (16.0 * moveY);

			If (Spawn("Nav_Block", destX, destY, ActorZ + 32.0, 2000 + ID, 0)) //Check if no object is in the way
			{
				If(CheckSight (2000 + ID, 1900 + ID, CSF_NOBLOCKALL)) //Check if destination is inside map
					intMoveDist += 32.0;
				Thing_Remove(2000 + ID);

				moves[(a / 64) + 1] = intMoveDist;
/*
				If (intMoveDist > dist)
				{
					dir = a;
					dist = intMoveDist;
				}
*/
			}
/*
			Else
			{
				moves[(a / 64) + 1] = 0;
				i = intMaxMove;
			}
*/
		}
		Thing_Remove(1900 + ID);
/*
		Switch (dir)
		{
			Case 0:
				printbold(d:ActorA / 1.0,s:" -> East ",d:dir * 360 / 256);
			break;
			Case 64:
				printbold(d:ActorA / 1.0,s:" -> North ",d:dir * 360 / 256);
			break;
			Case 128:
				printbold(d:ActorA / 1.0,s:" -> West ",d:dir * 360 / 256);
			break;
			Case 192:
				printbold(d:ActorA / 1.0,s:" -> South ",d:dir * 360 / 256);
			break;
		}
*/
		int current = ActorA / 64 + 1;

		int index, preferred, nextpreferred; // = current;

		For (int l = -1; l <= 2; l++)
//		For (index = 1; index <= 4; index++)
		{
			index = current + l;

			If (index > 4) index -= 4;
			If (index < 1) index += 4;

			If (moves[index] > moves[preferred])
			{
				nextpreferred = preferred;
				preferred = index;
				If (l >= 1) l = 2;
			}

//printbold(d:index,s:"\n",d:moves[index] / 1.0,s:" ? ",d:moves[preferred] / 1.0,s:"\n\nPreferred: ",d:preferred);
		}
		retValue = (preferred - 1) * 64 * 360 / 256;
//		printbold(s:"Move Options:\n\nN: ",d:moves[2]/1.0,s:"\nS: ",d:moves[4]/1.0,s:"\nW: ",d:moves[3]/1.0,s:"\nE: ",d:moves[1]/1.0,s:"\n\nCurrent: ",d:ActorA,s:"\nProposed: ",d:(preferred - 1) * 64);
//		log(d:(preferred - 1) * 64,s:": ",d:moves[preferred] / 1.0);
	}

//	SetResultValue(dir * 360 / 256);

	Thing_Remove(2000 + ID);
//Log(d:GetUserVariable(0, "user_angle"), s: " ? ", d:(retValue + 180) % 360);

	current = GetUserVariable(0, "user_angle");

/*
	If (Random(0, 1))
	{
		preferred = nextpreferred;
		retvalue = (nextpreferred - 1) * 64 * 360 / 256;
	}
*/

	If (current != ((retValue + 180) % 360))
		retValue = (nextpreferred - 1) * 64 * 360 / 256;

	SetUserVariable(0, "user_angle", retValue);
	SetResultValue(retValue);
}

Script "A_CheckAlert" (void)
{
	int intDelay = 6 * 35;

	If (RedAlert)
	{
		SetResultValue(intDelay - (Timer() % intDelay));
	}
	Else
		SetResultValue(0);
}

// Ship Scripts
int DoorStatus = 0;
int PadStatus = 0;
int PadMoving = False;
int Moved = 0;

Function void OpenDoor (void)
{
	PlaySound(0, "hangar/doors", CHAN_AUTO, 0.35);
	SetActorState(2, "Opening");
	DoorStatus = 1;
}

Function void CloseDoor (void)
{
	PlaySound(0, "hangar/doors", CHAN_AUTO, 0.35);
	SetActorState(2, "Closing");
	DoorStatus = 0;
}

Script "A_CheckDoorStatus" (void)
{
	SetResultValue(DoorStatus);
}

Script "MoveShuttle" (int Out, int Override)
{
	If (!Override)
	{
		If (GetActorZ(0) < -1536.0) terminate;
		If (Moved == Out) terminate;
	}

	If (PadStatus) terminate;

	int ShuttleX, ShuttleY, ShuttleZ;
	int i = 0;
	
	ShuttleX = GetActorX(551);
	ShuttleY = GetActorY(551);
	ShuttleZ = GetActorZ(551);

	PlaySound(0, "computer/button2");

	ReplaceTextures ("WALL_BEA", "WALL_BEB");

	PolyObj_Move(312, 32, 64, 120);
	Ceiling_LowerToFloor(36, 32);

	DoorStatus = 1;

	If (Out)
	{ //Rotate from North-facing to East
		For (int j = 0.25; j >= 0.0; j -= 0.001)
		{
			SetActorAngle(551, j);
			Delay(3);
		}
	}
	Else
	{
		ShuttleX = 11704.0;
		ShuttleY = -2972.0;
		ShuttleZ = -1348.0;

		SetActorPosition(551, ShuttleX, ShuttleY, ShuttleZ, 0); 

		SetActorAngle(551, 0.5);
	}

	OpenDoor();

	Delay(35 * 3);
	
	For (i = 0; i <= 1024; i = i + 3)
	{
		If (Out)
			SetActorPosition(551, ShuttleX + (i * 1.0), ShuttleY, ShuttleZ + (i * 0.15), 0); 
		Else
			SetActorPosition(551, ShuttleX - (i * 1.0), ShuttleY, ShuttleZ - (i * 0.15), 0);
		   
		Delay(1);
	}
	
	//CloseDoor();  
	PlaySound(0, "hangar/doors", CHAN_AUTO, 0.35);
	SetActorState(2, "Closing");
	
	For (i = 1024; i <= 2048; i = i + 3)
	{
		If (Out)
			SetActorPosition(551, ShuttleX + (i * 1.0), ShuttleY, ShuttleZ + (i * 0.15), 0);
		Else
			SetActorPosition(551, ShuttleX - (i * 1.0), ShuttleY, ShuttleZ - (i * 0.15), 0);
		
		Delay(1);
	}

	ReplaceTextures ("WALL_BEB", "WALL_BEA");

	If (!Out) {
		For (j = 0.5; j >= 0.25; j -= 0.001)
		{
			SetActorAngle(551, j);
			Delay(3);
		}

		SetActorState(551, "Land");
	}

	DoorStatus = 0;
	
	PolyObj_Move(312, 32, 192, 120);
	Ceiling_RaiseToNearest(36, 32);

	Moved = Out;
}

Script "MovePad" (void)
{
	If (GetActorZ(0) > -1656.0 && GetActorZ(0) < -1536.0) Terminate;

	If (!PadMoving && !DoorStatus)
	{
		PadMoving = True;	

		PlaySound(0, "computer/button2");

		If (PadStatus)
		{
			FloorAndCeiling_RaiseByValue(42, 5, 116);
			Floor_RaiseByValue(43, 5, 116);
		}
		Else
		{
			FloorAndCeiling_LowerByValue(42, 5, 116);
			Floor_LowerByValue(43, 5, 116);
		}

		Delay(70);
		PadStatus = !PadStatus;
		PadMoving = False;
	}
}

Script "OpenDoor" (int ID, int MaxHeight, int intAngle)
{
	If (DoorStatus == 0 && (GetActorZ(0) / 1.0 <= MaxHeight))
			PolyObj_DoorSlide(ID, 16, intAngle, 32, 105);
}

Script "OpenPolyDoor" (int ID, int MaxHeight, int intAngle)
{
	If (GetActorZ(0) / 1.0 <= MaxHeight && GetActorZ(0) / 1.0 >= (MaxHeight - 92))
		PolyObj_DoorSlide(ID, 16, intAngle, 32, 105);
}

Script "OpenPolyDoorSingle" (int ID, int MaxHeight, int intAngle)
{
	If (GetActorZ(0) / 1.0 <= MaxHeight && GetActorZ(0) / 1.0 >= (MaxHeight - 92))
		PolyObj_DoorSlide(ID, 16, intAngle, 47, 105);
}

Script "CheckInVacuum" ENTER
{
	int loop = 0;
	int bAutoHealStatus = bAutoHeal;
	
	While (DoorStatus)
	{
		bAutoHeal = 0;

		If (CheckActorFloorTexture(0, "SHU_FLR") ||
		CheckActorFloorTexture(0, "SHU_FLR2") ||
		CheckActorFloorTexture(0, "SHU_FLR3") ||
		CheckActorFloorTexture(0, "F_SKY1")
		)
		{
			If (loop > 1)
			{  
				DamageThing(loop * 19 / 20);
				FadeTo (0, 0, 0, 0.2 * (100 / GetActorProperty(0, APROP_Health)), 0.5);
				PlaySound(0, "actor/heartbeat", CHAN_AUTO);
			}
		}
		Delay(35 * 2);
		FadeTo (0, 0, 0, 0.0, 1.5);
		loop++;
		If (!DoorStatus)
		{
			PlaySound(0, "*gasp", CHAN_VOICE);
			/*
			int healthloop = 0;
			While (healthloop < 50)
			{
				GiveActorInventory(0, "Health", 1);
				Delay(5);
				healthloop++;
			}
			*/
		}
	}
	FadeTo (0, 0, 0, 0.0, 1.5);
	bAutoHeal = bAutoHealStatus;
	Delay(35);
	Restart;
}

Script "A_CheckOutdoors" (void)
{
	SetResultValue(CheckActorCeilingTexture(0, "F_SKY1"));
}

int FieldStates[16];

Script "ToggleField" (int FieldID, int WallIndex, int LineAngle)
{
	int FieldIndex = FieldID % 16;
	int State = FieldStates[FieldIndex];

	State = !State;

	SetLineTexture(FieldID - 100, SIDE_FRONT, TEXTURE_MIDDLE, StrParam(s:"WALL",d:WallIndex,s:"SW",d:State));

	FieldStates[FieldIndex] = State;

	If (State)
	{
		Line_SetBlocking(FieldID, BLOCKF_EVERYTHING, 0);
		Light_ChangeToValue(FieldID, GetSectorLightLevel(FieldID) + 32);
	}
	Else
	{
		Line_SetBlocking(FieldID, 0, BLOCKF_EVERYTHING);
		Light_ChangeToValue(FieldID, GetSectorLightLevel(FieldID) - 32);
	}

	ACS_NamedExecuteAlways("BumpField", 0, FieldID, 1, LineAngle);
}

Script "BumpField" (int FieldID, int Toggle, int LineAngle)
{
	int FieldIndex = FieldID % 16;
	int State = FieldStates[FieldIndex];

	If (Toggle || State)
	{
		SetLineTexture(FieldID, SIDE_FRONT, TEXTURE_MIDDLE, "FIELD_W");
		SetLineTexture(FieldID, SIDE_BACK, TEXTURE_MIDDLE, "FIELD_W");
	}

	If (!Toggle && State)
	{
		PlaySound(0, "world/spark1");
		Thing_Damage(ActivatorTID(), 1, MOD_ELECTRIC);

		LineAngle = LineAngle * 256 / 360;
		if (LineSide() != LINE_BACK) LineAngle += 128;
		ThrustThing(LineAngle, 5, 0, ActivatorTID());
	}

	Delay(5);

	SetLineTexture(FieldID, SIDE_FRONT, TEXTURE_MIDDLE, "-");
	SetLineTexture(FieldID, SIDE_BACK, TEXTURE_MIDDLE, "-");
}

Script "GrantAccess" (int intLevel)
{
	str strKey = StrParam(s:"AccessLevel",d:intLevel);

	PlaySound(0, "computer/button2");

//	log(l:strParam(s:"LOCK_", d:intLevel, s:"_G"));
	Notification("Access Granted!", StrParam(l:strParam(s:"LOCK_", d:intLevel, s:"_G")), "", 1);
	GiveActorInventory(ActivatorTID(), strKey, 1);
}

Script "OpenGarageDoor" (int sector, int speed, int lock)
{
	PlaySound(0, "computer/button2");
	Generic_Door(sector, speed, 1, 0, lock);
}

Script "Flight" (void)
{
	Flight = !Flight;

	FlightSpeed[PlayerNumber()] = 10;
	int intMoveDelay = 0;
	int intCrouchHold = 0;
	int intJumpHold = 0;
//	int intRise = 0;
//	int intLand = 0;

	int intOldActualSpeed = 0;

	While (Flight && CheckInventory("Health") > 0)
	{
		MorphActor(0, "Shuttle", "", 0x7FFFFFFF, MRF_NEWTIDBEHAVIOUR | MRF_FULLHEALTH, "None", "None");

		SetPlayerProperty(0, ON, PROP_FLY);
		SetPlayerProperty(0, ON, PROP_TOTALLYFROZEN);

		int intInput = GetPlayerInput(-1, INPUT_BUTTONS);
		int intOldInput = GetPlayerInput(-1, INPUT_OLDBUTTONS);
		int intPitch = GetPlayerInput(-1, INPUT_PITCH);
		int intYaw = GetPlayerInput(-1, INPUT_YAW);
		int intRoll = GetActorRoll(0);

		int intCurrentPitch = GetActorPitch(0);
		int intActualSpeed = GetSpeed(0);

		If (intInput & BT_FORWARD)
		{
			intPitch += 0.004;
		}
		Else If (intInput & BT_BACK)
		{
			intPitch -= 0.004;
		}

		If (intInput & BT_MOVELEFT) intRoll -= 0.004;
		Else If (intInput & BT_MOVERIGHT) intRoll += 0.004;

		If (intInput & BT_LEFT || intYaw > 0) intRoll -= 0.001;
		Else If (intInput & BT_RIGHT || intYaw < 0) intRoll += 0.001;

/*
		If (intInput & BT_JUMP && !(intOldInput & BT_JUMP))
		{
			FlightSpeed[PlayerNumber()] += 10;
		}

		If (intInput & BT_CROUCH && !(intOldInput & BT_CROUCH))
		{
			FlightSpeed[PlayerNumber()] -= 10;
		}

		If (intInput & BT_JUMP && !(intOldInput & BT_JUMP))
		{
			FlightSpeed[PlayerNumber()] += 10;
		}

		If (intInput & BT_CROUCH && !(intOldInput & BT_CROUCH))
		{
			FlightSpeed[PlayerNumber()] -= 10;
		}

		If (FlightSpeed[PlayerNumber()] > 100) FlightSpeed[PlayerNumber()] = 100;
		If (FlightSpeed[PlayerNumber()] < -10) FlightSpeed[PlayerNumber()] = -10;

		If (intInput & BT_CROUCH) && intOldInput & BT_CROUCH)
		{
			If (intCrouchHold > 15)
			{
				intLand = 1;
				FlightSpeed[PlayerNumber()] = 0;
			}
			Else
				intCrouchHold++;
		}
		Else
		{
			intCrouchHold = 0;
			intLand = 0;
		}

		If (intInput & BT_Jump) && intOldInput & BT_Jump)
		{
			If (intJumpHold > 15)
			{
				intRise = 1;
				FlightSpeed[PlayerNumber()] = 0;
			}
			Else
				intJumpHold++;
		}
		Else
		{
			intJumpHold = 0;
			intRise = 0;
		}
*/
		int intMoveZ = 0;

		If (intInput & BT_CROUCH && intOldInput & BT_CROUCH)
			intMoveZ--;

		If (intInput & BT_Jump && intOldInput & BT_Jump)
			intMoveZ++;

		int intNewPitch = GetActorPitch(0) + (Sin(GetActorRoll(0) + 0.25) * intPitch / 1.0) + (Cos(GetActorRoll(0) + 0.25) * intYaw / 1.0);
		int intNewAngle = GetActorAngle(0) + (Sin(GetActorRoll(0) + 0.25) * intYaw / 1.0) + (Cos(GetActorRoll(0) + 0.25) * -intPitch / 1.0);

		If (Abs(intNewPitch) > 0.24999 && intPitch)
		{
			intRoll += 0.5;
			intNewAngle += 0.5;
		}

		ChangeActorRoll(0, intRoll, TRUE);
		SetActorAngle(0, intNewAngle);
		SetActorPitch(0, intNewPitch);

		If (Abs(intMoveDelay) >= 5 - FlightSpeed[PlayerNumber()])
		{
/*
			int intMoveZ = 0;

			If (intRise == 1)
			{
				SetActorState(0, "Landed");
				ThrustThingZ(0, 10, 0, 0);
				intMoveDelay = 0;
				FlightSpeed[PlayerNumber()] = 0;
			}
			Else If (intLand == 1)
			{
				SetActorState(0, "Landed");
				ThrustThingZ(0, -10, 0, 0);
				intMoveDelay = 0;
				FlightSpeed[PlayerNumber()] = 0;
			}
*/
			If (FlightSpeed[PlayerNumber()] > 0)
			{
				SetActorState(0, "Flight");

				SetActorVelocity(0, 0, 0, 0, 0, 1);
				ThrustThing(GetActorAngle(0) >> 8, FlightSpeed[PlayerNumber()] / 10, 0, 0);
			
				intMoveZ = Sin(GetActorPitch(0)) >> 8;

				ThrustThingZ(0, -intMoveZ / 10, 0, 0);

				intMoveDelay = 0;
			}
			Else If (FlightSpeed[PlayerNumber()] == -10)
			{
				SetActorState(0, "Flight");

				SetActorVelocity(0, 0, 0, 0, 0, 1);
				ThrustThing((GetActorAngle(0) >> 8) + 128, 1, 0, 0);

				intMoveZ = Sin(GetActorPitch(0)) >> 8;

				ThrustThingZ(0, intMoveZ / 10, 0, 0);

				intMoveDelay = 0;

			}

//			If (intInput & BT_ATTACK) SetActorState(0, "Fire");
		}
		Else
		{
			intMoveDelay++;
		}
/*
		int intSpeedDelta = Abs(intOldActualSpeed - intActualSpeed);
		If (intSpeedDelta > 20)
		{
			DamageThing(intSpeedDelta / 2);
		}
*/
		int intWeaponNum = GetUserVariable(0, "user_weapon");

		If (intWeaponNum > 1)
		{
			SetHudSize(640, 480, 1);
			SetFont(StrParam(s:"WPN", d:intWeaponNum, s:"A0"));
			HudMessage(s:"A"; HUDMSG_LAYER_OVERHUD, 1, -1, 32.1, 32.1, 1);
		}
		Else
			HudMessage(s:""; 0, 1, 0, 0, 0, 0);

		intOldActualSpeed = intActualSpeed;

		Delay(1);
	}

	UnMorphActor(0);

	SetPlayerProperty(0, OFF, PROP_FLY);
	SetPlayerProperty(0, OFF, PROP_TOTALLYFROZEN);
}

Script "A_SetupThing" (void)
{
	str strLookup = strParam(s:GetActorClass(0),s:"_",n:PRINTNAME_LEVEL,s:"_",d:ActivatorTID());
	str strData = strParam(l:strLookup);

	If (StrCmp(strData, strLookup) != 0)
		SetActorProperty(0, APROP_NameTag, strData);
	Else
		If (GetCVar("g_debug") > 0) SetActorProperty(0, APROP_NameTag, strLookup);
}

Script "RollActor" (int TID, int angle, int tics)
{
	int oldRoll = GetActorRoll(TID);

	SetActorRoll(TID, angle);
	Delay(tics);
	SetActorRoll(TID, oldRoll);
}

Script "TurnActor" (int TID, int angle, int tics)
{
	int oldAngle = GetActorAngle(TID);

	SetActorAngle(TID, angle);
	Delay(tics);
	SetActorAngle(TID, oldAngle);
}

Function void Notification(str strTitle, str strContent, str strLogOnlyContent, bool bLog)
{
	str strString = StrParam(s:"\ck", s:strTitle, s:"\n\cc", s:strContent);

	For (int i = 10000; i <= 11000; i++)
	{
		HudMessage (s:""; 0, i, -1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	}

	If (GetInput)
		DrawString(StrParam(s:"\ck", s:strTitle, s:"\n\cc", s:strContent), 0, 15000, 20.1, 40.1, 3, 1.0, 1.0, 1.0, 1.0, 5.0, 4);
	Else
	{
		DrawString(strString, 0, 15000, 740.1, 140.1, 3, 1.0, 1.0, 1.0, 1.0, 5.0, 4);
		SetFont("MSGBOX");
		SetHudSize(320, 200, 0);
		HudMessage (s:"A"; HUDMSG_FADEINOUT | HUDMSG_ALPHA, -15000, -1, 70.1, 5.1, 4.0, 1.0, 1.0, 0.6);
	}

	If (bLog)
	{
		If (StrLen(strLogOnlyContent) > 0)
			HudMessage (s:strString, s:"\n\n", s:strLogOnlyContent; HUDMSG_LOG | HUDMSG_ALPHA, 4000, 0, 0, 0, 0, 0);
		Else
			HudMessage (s:strString; HUDMSG_LOG | HUDMSG_ALPHA, 4000, 0, 0, 0, 0, 0);
	}
}

Script "TestMessage" (int R, int G, int B, int A)
{
	R = R * 1.0 / 256;
	G = G * 1.0 / 256;
	B = B * 1.0 / 256;
	A = A * 1.0 / 256;

	Notification("Hello!", "This is a message", "This is only in the console!", 1);
//	DrawString("This is a message\r.\n\caWoohoo!\n\n\cbL\cco\cdt\ces \cfo\cgf \chc\cio\cjl\cko\clr\cms \cna\cor\cpe \cqa\crv\csa\cti\cul\cva\clble!", 0, 0, CanvasWidth * 1.0 / 3 + 0.1, CanvasHeight * 1.0 / 3, 4/*, "FNT_Y", 3*/, 0.85, 1.0, 0.0, 1.0, 1.0, 4);
}

Script "A_CheckBeamUp" (void)
{
	ActivatorSound("transporter/energize", 128);
	SetUserVariable(0, "user_travel", 1);
	GiveInventory("TransportOut", 1);

	Delay(35 * 5);

	SetActorProperty(0, APROP_INVULNERABLE, 0);
	SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);

	ChangeLevel ("SHIP", 3 + PlayerNumber(), CHANGELEVEL_NOINTERMISSION | CHANGELEVEL_PRERAISEWEAPON, -1);
}

#define DropClassCount 12

str DropClasses[DropClassCount] = {
	"", 			//0
	"ChargePack", 
	"PhaserType1", 
	"PhaserType2", 
	"RifleChargePack", 
	"Tricorder", 		//5
	"PhotonGrenadeAmmoBox", 
	"PhotonGrenadeLauncher", 
	"AccessLevel2", 
	"AccessLevel3", 
	"AccessLevel4", 	//10
	"MedKit" 
};

Script "A_Drop" (int DropIndex)
{
	str strDropItem = "";

	strDropItem = strParam(s:DropClasses[DropIndex]);

	int itemTID = UniqueTID();

	Spawn (strDropItem, GetActorX(0), GetActorY(0), GetActorZ(0), itemTID);
	SetActorProperty(itemTID, APROP_Dropped, 0);
}

Script "ChangeCamera" (int CameraTID, int timeDelay)
{
	int timeElapsed = 0;

	SetCameraToTexture(cameraTID, "TITLECAM", 90);

	SetHudSize(1280, 960, 1);
	SetFont("TITLECAM");
	HudMessage (s:"A"; 0, 2, -1, 640.0, 480.0, 0);

	SetHudSize(800, 600, 1);
	SetFont("VIEWBORD");
	HudMessage (s:"A"; 0, 1, -1, 400.0, 300.0, 0);

	int loop = 1;

	While(loop)
	{
		If (GetPlayerInput(-1, INPUT_FORWARDMOVE) + GetPlayerInput(-1, INPUT_SIDEMOVE)) loop = 0;
		If (timeDelay > 0 && timeElapsed >= timeDelay) loop = 0;
		timeElapsed++;
		Delay(1);
	}

	HudMessage (s:""; 0, 2, 0, 0, 0, 0);
	HudMessage (s:""; 0, 1, 0, 0, 0, 0);
}

Script "StepThrust" (int angle)
{
	SetActivatorToTarget(0);
	int intPlayerAngle = GetActorAngle(ActivatorTID()) * 360 / 1.0;
	int intAngleDelta = abs(angle - intPlayerAngle);

	If (intAngleDelta < 45 && GetPlayerInput(-1, INPUT_FORWARDMOVE))
	{ //Forward and up?
//		ThrustThing(GetActorAngle(ActivatorTID()) * 256 / 1.0, 8, 0, ActivatorTID());
		ThrustThingZ(ActivatorTID(), 8, 0, 0);
	}
}

function void Letterbox (int OnOff)
{
	CutScene = OnOff;

	If (OnOff > 0)
	{
		SetFont("DARKGREY");
		SetHudSize(320, 200, 0);
		HudMessage (s:"A"; 0, 100, -1, 0.0, -70.0, 0);
		HudMessage (s:"A"; 0, 102, -1, 320.0, -70.0, 0);
		HudMessage (s:"A"; 0, 101, -1, 0.0, 270.0, 0);
		HudMessage (s:"A"; 0, 103, -1, 320.0, 270.0, 0);
	}
	Else
	{
		SetHudSize(320, 200, 0);
		HudMessage (s:""; 0, 100, -1, 0.0, 0.0, 0);
		HudMessage (s:""; 0, 101, -1, 0.0, 0.0, 0);
		HudMessage (s:""; 0, 102, -1, 0.0, 0.0, 0);
		HudMessage (s:""; 0, 103, -1, 0.0, 0.0, 0);
		HudMessage (s:""; 0, -1000, 0, 0, 0, 0, 0);
	}
}

Script "QuickFade" (void)
{
	If (!SkipCutscene)
	{
		FadeToGraphic("Black_Ful", 0.1, 0.5, 0.5);
		Delay(14);
	}
}

Script "Cutscene" (int index, int inTime, int outTime)
{
	str strLookupName;
	str strLookupData = " ";
	str strString;
	int i = 0;
	int hold = 0;
	int posv = 720.2;
	int pos = 0.0;

	SetPlayerProperty(1, 1, PROP_TOTALLYFROZEN);

	FadeToGraphic("Black_Ful", 1.0, inTime * 1.0, outTime * 1.0);

	Delay(inTime * 35 + 5);

	Letterbox(1);

	SetHudSize(1024, 768, 0);
	SetFont("BIGFONT");
	strLookupName = strParam(s:"Cutscene_",n:PRINTNAME_LEVEL,s:"_",d:index, s:"_", d:i);

	strLookupData = strParam(l:strLookupName);

	While (StrCmp(strLookupData, strLookupName))
	{
		SetPlayerProperty(1, 1, PROP_TOTALLYFROZEN);

		If (SkipCutscene)
		{
			SetHudSize(1280, 960, 1);
			SetFont("Black_Ful");
			HudMessage (s:"A"; HUDMSG_LAYER_OVERHUD, 1, -1, 640.0, 480.0, 0);
			Log(s:"...");
		}

		SplitString(strLookupData, '~');

		If (StrCmp(CutsceneData[0], "") != 0 && IntFromString(CutsceneData[0]) > 0)
		{
			//ChangeCamera(IntFromString(CutsceneData[0]), 1, 0);
			// Use texture instead of direct camera so the camera has modifiable FOV...
			SetHudSize(1280, 960, 1);
			SetCameraToTexture(IntFromString(CutsceneData[0]), "CUTSCENE", 35);
			SetFont("CUTSCENE");
			HudMessage (s:"A"; HUDMSG_LAYER_OVERHUD, -1000, -1, 640.0, 480.0, 0);
		}
		Else
		{
			ChangeCamera(0, 1, 0);
			HudMessage (s:""; 0, -1000, 0, 0, 0, 0, 0);
		}

		hold = StrLen(CutsceneData[2]) * 1.0 / 20;

		posv = 720.2;

		If (StrCmp(CutsceneData[3], "L") == 0)
		{
			pos = 32.1;
		}
		Else If (StrCmp(CutsceneData[3], "R") == 0)
		{
			pos = 992.2;
		}
		Else If (StrCmp(CutsceneData[3], "T") == 0)
		{
			pos = 32.1;
			posv = 32.1;
		}
		Else
		{
			pos = 512.0;
		}

		If (StrCmp(CutsceneData[4], "") != 0)
		{
			ACS_NamedExecuteWait(CutsceneData[4], 0);
		}

		SetHudSize(1024, 768, 0);
		SetFont("BIGFONT");

		If (StrCmp(CutsceneData[2], "") != 0)
		{
			If (StrCmp(CutsceneData[1], "") != 0)
				strString = strParam(s:"\cj", s:CutsceneData[1], s:":\cl\n", s:CutsceneData[2]);
			Else
				strString = strParam(s:CutsceneData[2]);

			HudMessage(s:strString; HUDMSG_FADEINOUT | HUDMSG_COLORSTRING | HUDMSG_LOG, 99 - i, "TOSGold", pos, posv, hold, 0.5, 1.0);

			ACS_NamedExecuteWait("CutsceneDelay", 0, (hold + 2.5) * 35 / 1.0);
		}

		If (StrCmp(CutsceneData[5], "") != 0)
			ACS_NamedExecuteWait("CutsceneDelay", 0, IntFromString(CutsceneData[5]));

		i++;

		strLookupName = strParam(s:"Cutscene_",n:PRINTNAME_LEVEL,s:"_",d:index, s:"_", d:i);
		strLookupData = strParam(l:strLookupName);

		If (GetCVar("developer") == 0) SkipCutscene = False;
	}

	FadeToGraphic("Black_Ful", 1.0, (1 - SkipCutscene) * 1.0, 1.0);

	Delay(35);

	SkipCutscene = False;

	If (outTime > 0) //No outtime assumes end of level, so don't reset
	{
		ChangeCamera(0, 1, 0);
		SetPlayerProperty(1, 0, PROP_TOTALLYFROZEN);
		Letterbox(0);
		Autosave();
	}
}

Script "CommUp" (void)
{
	Weapon[PlayerNumber()] = GetWeapon();
	SetWeapon("TOSCommunicator");
	Delay(35);
}

Script "CommDown" (void)
{
	Delay(5);
	SetWeapon(Weapon[PlayerNumber()]);
}

Script "Chirp" (void) //TODO:  Combine with CommUp?
{
	PlaySound(0, "actor/communicator/beep", CHAN_BODY, 0.1);
	Delay(50);
}

Script "HidePlayer" (void) //Used to prep for levels where player beams in during cutscene
{
	SetActorProperty(0, APROP_RenderStyle, STYLE_Translucent);
	SetActorProperty(0, APROP_Alpha, 0);
}

Script "ShowPlayer" (void)
{
	SetActorProperty(0, APROP_RenderStyle, STYLE_Translucent);
	SetActorProperty(0, APROP_Alpha, 255);
}

Script "GameSkill" (void)
{
	SetResultValue(GameSkill() + 1);
}

Script "Title" (void)
{
	int d;
	int bShadows = TRUE;

	SetHudSize(256, 192, 0);
	SetFont("BIGFONT");

	str strTitleLookup = StrParam(s:"Title_",n:PRINTNAME_LEVEL);
	str strTitle = StrParam(c:'"',l:strTitleLookup,c:'"');
	str strCreditLookup = StrParam(s:"Credit_",n:PRINTNAME_LEVEL);

	HudMessage(s:strTitle; HUDMSG_FADEINOUT | HUDMSG_COLORSTRING, 94, "TOSGold", 128.0, 44.1, 2.5, 0.5, 1.0);

	If (bShadows)
	{
		ACS_NamedExecuteWait("CutsceneDelay", 0, 16);
		HudMessage(s:strTitle; HUDMSG_FADEINOUT | HUDMSG_COLORSTRING, 95, "TrueBlack", 129.0, 45.1, 1.5, 0.5, 0.5);
		ACS_NamedExecuteWait("CutsceneDelay", 0, 17);
	}
	Else
		ACS_NamedExecuteWait("CutsceneDelay", 0, 35);

	SetHudSize(576, 432, 0);
	HudMessage(l:"StoryByString"; HUDMSG_FADEINOUT | HUDMSG_COLORSTRING, 96, "TOSGold", 50.1, 266.1, 1.5, 0.5, 1.0);

	SetHudSize(384, 288, 0);
	HudMessage(l:strCreditLookup; HUDMSG_FADEINOUT | HUDMSG_COLORSTRING, 98, "TOSGold", 33.1, 192.1, 1.5, 0.5, 1.0);

	If (bShadows)
	{
		ACS_NamedExecuteWait("CutsceneDelay", 0, 16);
		SetHudSize(576, 432, 0);
		HudMessage(l:"StoryByString"; HUDMSG_FADEINOUT | HUDMSG_COLORSTRING, 97, "TrueBlack", 52.1, 268.1, 0.5, 0.5, 0.5);
		SetHudSize(384, 288, 0);
		HudMessage(l:strCreditLookup; HUDMSG_FADEINOUT | HUDMSG_COLORSTRING, 99, "TrueBlack", 35.1, 194.1, 0.5, 0.5, 0.5);
		ACS_NamedExecuteWait("CutsceneDelay", 0, 87);
	}
	Else
		ACS_NamedExecuteWait("CutsceneDelay", 0, 3 * 35);
}

Script "CutsceneDelay" (int duration)
{
	For (int d = 0; d <= duration; d++)
	{
		Delay(1);
		If (SkipCutscene)
		{
			HudMessage (s:""; 0, 90, -1, 0.0, 0.0, 0);
			HudMessage (s:""; 0, 91, -1, 0.0, 0.0, 0);
			HudMessage (s:""; 0, 92, -1, 0.0, 0.0, 0);
			HudMessage (s:""; 0, 93, -1, 0.0, 0.0, 0);
			HudMessage (s:""; 0, 94, -1, 0.0, 0.0, 0);
			HudMessage (s:""; 0, 95, -1, 0.0, 0.0, 0);
			HudMessage (s:""; 0, 96, -1, 0.0, 0.0, 0);
			HudMessage (s:""; 0, 97, -1, 0.0, 0.0, 0);
			HudMessage (s:""; 0, 98, -1, 0.0, 0.0, 0);
			HudMessage (s:""; 0, 99, -1, 0.0, 0.0, 0);
			d = duration;
		}
	}
}