class TrekEnemy : Actor //For common inheritance of action functions
{
	int user_Ammo;
	int user_FireCount;
	double old_angle;
	double old_pitch;
	double old_roll;
	Actor lastDamageSource;

	override int TakeSpecialDamage(Actor inflictor, Actor source, int damage, Name damagetype)
	{
		if (source.bMissile && source.target && source.target != self) { self.lastDamageSource = source.target; }
		else { self.lastDamageSource = source; }

		return damage;
	}
}

extend class TrekEnemy
{
	void A_FireDisruptor(int variance = 1, int ammoamt = 1, double zoffset = 60, double yoffset = 0)
	{
		old_pitch = pitch;
		old_roll = roll;
		let mo = A_SpawnProjectile("DisruptorBolt", zoffset, yoffset, Random[Disruptor](-variance, variance), CMF_OFFSETPITCH | CMF_SAVEPITCH | CMF_BADPITCH, Random[Disruptor](-variance, variance), AAPTR_TARGET);
		mo.master = self;
		mo.tracer = target;
		user_ammo -= ammoamt;
		angle = old_angle;
		pitch = old_pitch;
		roll = old_roll;
	}

	void A_FireDisruptorGrenade(int variance = 5, int ammoamt = 10)
	{
		bNoRadiusDmg = True;
		A_SpawnProjectile("DisruptorGrenade", 60, 0, Random[Disruptor](-variance, variance), CMF_OFFSETPITCH | CMF_SAVEPITCH | CMF_BADPITCH, FRandom[Disruptor](variance, 15 * (GetZAt(0, 0, 0, GZF_CEILING) / 128.0)), AAPTR_TARGET);
		user_ammo -= ammoamt;
	}

	void A_FirePhaser(class<Actor> beam, class<Actor> light, class<Actor> hitpuff, int damage = 10, int ammoamt = 1, sound snd = "weapons/phaser_alt", int xoffset = 14, double zoffset = 50)
	{
		double old_height;

		old_pitch = pitch;
		old_roll = roll;
		A_PlaySound(snd, 0, 1.0);
		user_ammo -= ammoamt;
		old_height = height;
		height = 0;
		A_CustomRailgun(damage, xoffset, "", "", RGF_CENTERZ | RGF_NOPIERCING | RGF_FULLBRIGHT |  RGF_SILENT, 1, 0, hitpuff, 0, 0, 2048, 4, 1.0, 0, beam, zoffset);
		A_CustomRailgun(0, xoffset, "", "", RGF_CENTERZ | RGF_NOPIERCING | RGF_FULLBRIGHT | RGF_SILENT, 1, 0, "NoPuff", 0, 0, 2048, 1, FRandom(6.0, 8.0), 0, light, zoffset);
		height = old_height;
		angle = old_angle;
		pitch = old_pitch;
		roll = old_roll;
	}

	void A_FireTorpedo(class<Actor> torpedo, int ammoamt = 1, double xoffset = 0, double zoffset = 60, bool gravity = false)
	{
		old_pitch = pitch;
		old_roll = roll;
		let mo = A_SpawnProjectile(torpedo, zoffset, xoffset, Random[Torpedo](-1, 1), CMF_OFFSETPITCH | CMF_SAVEPITCH | CMF_BADPITCH, Random[Torpedo](-1, 1), AAPTR_TARGET);

		if (mo)
		{
			mo.bNoGravity = !gravity;
			mo.master = self;
			mo.tracer = target;
			user_ammo -= ammoamt;
		}

		angle = old_angle;
		pitch = old_pitch;
		roll = old_roll;
	}
}

class TrekEnemyActor : TrekEnemy
{
	int user_Health;
	int user_State;
	int user_Width;
	int user_Height;
	int user_Uses;
	int user_Stunned;
	int user_Weapon;
	double user_Angle;
	double user_Pitch;
	double user_Speed;

	Default
	{
		MONSTER;
		+FLOORCLIP;
		+NOTARGET;
		Health 75;
		Speed 6;
		Radius 10;
		Height 70;
		YScale 1.33;
		DeathHeight 0;
		Mass 100;
		Painchance 128;
		BloodColor "FF 00 00";
		DamageFactor "Trek", 0.0;
		Species "Enemy";
		Activation THINGSPEC_NoDeathSpecial;
		Obituary "%o was killed by an ill-defined replacement actor.";
		YScale 1.33;
	}

	States
	{
		Spawn:
			"####" A 0 NoDelay {
				ACS_NamedExecuteAlways("SetRadarTID",0);
				ACS_NamedExecuteAlways("A_SetupThing",0);

				if (user_Speed < 0) {
					Speed = 0;
				}
				user_Speed = Speed;

				user_ammo = Random[EnemyAmmo](0, 30);
			}
			"####" # 0 A_Jump(256, "Stand");
		Stand:
			"####" A 0 {
				user_State = 2;
				if (speed == 0) {
					return ResolveState("CrouchLook");
				}
				return ResolveState(null);
			}
		Stand.Loop:
			"####" # 1 A_LookEx (0, 0, 0, 2048, 0, "Chase");
			Loop;
		CheckSight:
			"####" # 0 A_CheckLOF("Missile.Shoot", CLOFF_SKIPOBSTACLES);
			"####" A 0 {
				return ResolveState("Return");
			}
		Wander:
			"####" # 0 {
				bNoRadiusDmg = False;
				user_State = 1;
				if (user_Speed == 0) {
					return ResolveState("Crouch");
				} else {
					Speed = user_speed;
					return ResolveState(null);
				}
			}
			"####" AAAAA 1 A_Chase (null, null);
			"####" AA 1;
			"####" BBBB 1 A_Chase (null, null);
			"####" CCCCC 1 A_Chase (null, null);
			"####" CC 1;
			"####" DDDD 1 A_Chase (null, null);
		Chase:
			"####" A 0 {
				ACS_NamedExecuteAlways("A_CheckFrightened");
				user_State = 1;
				if (waterlevel > 1) {
					bFloat = True;
					Speed /= 2;
					bNoGravity = True;
				} else {
					bFloat = False;
					bNoGravity = False;

					If (Speed == 0) {
						return ResolveState("Crouch");
					}

					Speed == user_Speed;
				}
				return ResolveState(null);
			}
			"####" AAAAA 1 A_Chase("CheckSight", "CheckSight");
			"####" AA 1;
			"####" BBBB 1 A_Chase("CheckSight", "CheckSight");
			"####" CCCCC 1 A_Chase("CheckSight", "CheckSight");
			"####" CC 1;
			"####" DDDD 1 A_Chase("CheckSight", "CheckSight");
			"####" # 0 {
				if (bFrightened)
				{
					return ResolveState("Frightened");
				}
				return ResolveState(null);
			}
			Loop;
		CrouchLook:
			"####" X 1 A_LookEx (0, 0, 0, 2048, 0, "Crouch");
			Loop;
		Crouch:
			"####" # 0 {
				if (user_Speed > 0 && A_CheckLOF("Return.Speed", CLOFF_FROMBASE, 0, 0, 0, 0, 24.0)) {
					return ResolveState("Return.Speed");
				} else {
					return ResolveState(null);
				}
			}
			"####" VVVWWW 1;
			"####" XXX 1 {
				Height = Height / 2;
				A_FaceTarget();
				A_SetTics(Random[Crouch](5, 52));
				bNoRadiusDmg = False;
				if (user_Ammo < 30) {
					user_Ammo += 10;
				}
			}
			"####" XW 1 {
				if (user_Speed > 0) {
					A_Chase(null, null, CHF_FASTCHASE);
				}
			}
			"####" X 35 {
				A_FaceTarget();
				A_SetTics(Random(35, 105));
			}
			"####" WWWVVV 1;
			"####" V 1 {
				A_SetTics(Random[Popup](5, 15));
				Height = Height * 2;
			}
			Goto CheckSight;
		Melee:
		Missile:
			"####" EE 3 {
				A_FaceTarget();
				if (waterlevel > 1) {
					return ResolveState("Chase");
				} else {
					return ResolveState(null);
				}
			}
		Missile.Shoot:
			"####" # 0 {
				Speed == user_Speed;

				if (user_ammo <= 0) {
					return ResolveState("Chase");
				}

				if (user_Weapon == 1) {
					if (GetDistance(TRUE) >= 256.0) {
						return ResolveState("Fire.Grenade");
					} else {
						return ResolveState("Fire");
					}
				} else if (user_Weapon == 2) {
					return ResolveState("Fire.Rifle");
				} else if (user_Weapon == 3) {
					return ResolveState("Fire.Phaser");
				} else {
					return ResolveState("Fire");
				}
			}
			"####" A 0 A_Jump(256, "Return");
		Fire:
			"####" # 0 A_JumpIf(user_FireCount > 3, "Return");
			"####" F 1 A_FireDisruptor();
			"####" EE 3 A_FaceTarget();
			"####" F 1 A_FireDisruptor(2);
			"####" EE 3 A_FaceTarget();
			"####" F 1 A_FireDisruptor();
			"####" EE 8 A_FaceTarget();
			"####" # 0 { user_FireCount++; }
			"####" # 0 A_JumpIfHealthLower(2, "Disintegrate",  AAPTR_TARGET);
			"####" A 0 A_Jump(128, "CheckSight");
			Goto Chase;
		Fire.Grenade:
			"####" # 0 A_Jump(128, "Fire");
			"####" F 1 A_FireDisruptorGrenade();
			"####" EE 3 A_FaceTarget();
			"####" A 0 A_Jump(256, "Wander");
		Fire.Rifle:
			"####" F 0 A_JumpIf(user_FireCount > 40, "Return");
			"####" F 1 A_FirePhaser("LaserBeam_P", "SmallPurpleLight", "PhaserHitW", 12, 2, "weapons/rifle");
			"####" A 0 A_Jump(256, "CheckSight");
		Fire.Phaser:
			"####" A 0 A_JumpIf(user_FireCount > 10, "Return");
			"####" F 1 A_FirePhaser("LaserBeam_R", "SmallRedLight", "PhaserDisintegrateHit");
			"####" A 0 A_Jump(256, "CheckSight");
		Return:
			"####" # 0 {
				A_StopSound(CHAN_WEAPON);
				user_FireCount = 0;
				if (user_ammo <= 0) {
					bFrightened = True;
				}
			}
			"####" # 0 A_CheckLOF("Return.Speed", CLOFF_FROMBASE, 0, 0, 0, 0, 24.0);
			"####" # 0 {
				if (Random(0, 256) < 128) {
					Speed = 0;
				} else {
					Speed = user_Speed;
				}
			}
			Goto Chase;
		Return.Speed:
			"####" # 0 {
				Speed = user_Speed;
			}
			Goto Chase;
		Pain:
			"####" G 3;
			"####" G 3 A_Pain;
			Goto Wander;
		Death:
			"####" H 5 {
				A_StopSound(CHAN_WEAPON); //Just in case
				A_CallSpecial(special, args[0], args[1], args[2], args[3], args[4]);
				A_NoBlocking();
			}
			"####" I 5 {
				A_Scream();
				if (user_Weapon == 2) {
					A_DropItem("PhaserRifle", user_ammo);
				} else if (user_Weapon == 3) {
					A_DropItem("PhaserType2", user_ammo);
				} else {
					A_DropItem("Disruptor", user_ammo);
				}
			}
			"####" JK 5;
			"####" L -1;
			Stop;
		Death.Stun:
			"####" H 5 {
				A_UnSetSolid();
				bShootable = False;
				A_StopSound(CHAN_WEAPON); //Just in case
			}
			"####" I 5 A_Scream();
			"####" JK 5;
			"####" L -1;
			Stop;
		XDeath:
			"####" M 5 {
				A_StopSound(CHAN_WEAPON); //Just in case
				A_CallSpecial(special, args[0], args[1], args[2], args[3], args[4]);
				A_NoBlocking();
			}
			"####" N 5 A_XScream;
			"####" OPQRST 5;
			"####" U -1;
			Stop;
		Raise:
			"####" K 5 {
				A_SetSolid();
				bShootable = True;
			}
			"####" JIH 5;
			Goto Chase;
		Disintegrate:
			"####" # 0 A_GiveInventory("Disintegration", 1, AAPTR_TARGET);
			"####" # 0 A_ClearTarget;
			Goto Wander;
		Frightened:
			"####" A 0 {
				if (user_ammo < 30)
				{
					user_Ammo += 5;
				}
			}
			"####" A 0 A_Jump(256, "Chase");
	}
}

class TrekEnemyFlier : TrekEnemy
{
	bool bDoFire;
	bool hasCloak;
	double centerzoffset;
	double centerxoffset;
	double scaleheight;
	double fov;
	double turnradius;
	bool passive;
	int timeout;
	int continuousfirethreshold;
	int turndir;
	int torpedochance;

	Property FOV:fov;
	Property Maneuverability:turnradius;
	Property CanCloak:hascloak;
	Property NonAggressive:passive;
	Property TorpedoChance:torpedochance;
	Property CenterofGravityZ:centerzoffset;
	Property CenterofGravityX:centerxoffset;

	Default
	{
		MONSTER
		+NOGRAVITY;
		+NOBLOOD;
		+DONTTHRUST;
		YScale 1.0;
		Painchance 256; //Really just for how often the shield flare/damage shows up.
		Height 32;
		Radius 32;
		Speed 1;
		Health 1000;
		Mass 500;
	}

	States
	{
		Spawn:
			TOS1 A 1;
			"####" # 0 {
				if (bFriendly) { passive = True; species = "Starfleet"; }
				else if (species == "Starfleet") { species = "Pirate"; }
				scaleheight = height;
				height = max(height, 32);
				return ResolveState("Stand");
			}
		Stand:
			"####" # 1 {
				ACS_NamedExecuteAlways("SetRadarTID",0);
				ACS_NamedExecuteAlways("A_SetupThing",0);
				bDoFire = False;
				bNoGravity = True; //Just in case?
			}
			"####" # Random(0, 35);
			"####" # 1 {
				return ResolveState("Chase");
			}
		Chase:
			"####" # 1;
			"####" # 0 {
				A_ShipLookChase(turnradius, fov);
			}
			Loop;
		Missile:
		Missile.KlingonTorpedo:
			"####" # 1;
			"####" # 0 {
				if (Random[TorpedoJump]() < torpedochance) {
					A_FireTorpedo("DisruptorGrenade", zoffset: 0);
					timeout = 70;
					return ResolveState("Chase");
				}
				return ResolveState("Missile.Disruptor");
			}

		Missile.Disruptor:
			"####" # 10;
			"####" # 0 {
				if (user_FireCount > 3) {
					timeout = 70;
					user_FireCount = 0;
				} else {
					A_FireDisruptor(0, zoffset:16 * (1 - sin(roll)), yoffset: 18 * cos(roll));
					A_FireDisruptor(0, zoffset:16 * (1 + sin(roll)), yoffset: -18 * cos(roll));
					timeout = 10;
					user_FireCount++;
				}
				return ResolveState("Chase");
			}
		Missile.Torpedo:
			"####" # 1;
			"####" # 0 {
				if (Random[TorpedoJump]() < torpedochance) {
					A_FireTorpedo("PhotonTorpedo", zoffset: 0);
					timeout = 70 + 32 - torpedochance;
					return ResolveState("Chase");
				}
				return ResolveState("Chase");
			}
		Missile.RomulanTorpedo:
			"####" # 1;
			"####" # 0 {
				A_FireTorpedo("RomulanTorpedo", zoffset: 0);
				timeout = 350;
				return ResolveState("Chase");
			}
		Pain:
			"####" # 1; 
			"####" # 0 {
				A_CallHelp();
				A_DamageSigns(True, centerzoffset, centerxoffset);
				A_ShipLookChase(turnradius, fov);
				return ResolveState("Chase");
			}
		Death:
		XDeath:
			"####" # 45 {
				A_RemoveChildren(True, RMVF_EVERYTHING);
				A_Scream();
				bNoGravity = True;
				A_Stop();
				ACS_NamedExecuteAlways("A_Disintegrate", 0, 16743936, 1);
				A_SetScale(0.5);
				A_SpawnItemEx("FlareUp", flags:SXF_TRANSFERSCALE);
				A_SetScale(1.25);
				A_SetPitch(pitch + FRandom(-30.0, 30.0), SPF_INTERPOLATE);
				A_SetRoll(roll + FRandom(-30.0, 30.0), SPF_INTERPOLATE);
			}
			Stop;
	}
}

extend class TrekEnemyFlier
{
	vector3 old_pos;
	double anglediff;
	double old_z;
	double destangle;
	double destz;
	double longrun;
	int floatdir;
	int bursttimeout;
	int runtime;
	int dodgetime;
	bool bRun;
	bool attacked;
	actor nexttarget;

	void A_CallHelp(double range = 2048, int maxhelp = 3)
	{
		int helpercount;

		ThinkerIterator FriendFinder = ThinkerIterator.Create("TrekEnemyFlier");
		TrekEnemyFlier mo;
		while ( (mo = TrekEnemyFlier(FriendFinder.Next())) && (helpercount < maxhelp) )
		{
			if (mo.bFriendly != bFriendly) { continue; }
			if (mo == self || mo.health <= 0 || mo.target || mo.bDormant) { continue; }

			if (Distance3d(mo) > range) { continue; }

			mo.passive = False;
			mo.runtime = 0;

			mo.target = target;
			helpercount++;
		}
	}

	actor A_ClosestActor(void)
	{
		ThinkerIterator Finder = ThinkerIterator.Create("TrekEnemyFlier");
		Actor mo, closest;
		while ( (mo = TrekEnemyFlier(Finder.Next())) )
		{
			if (mo == self || mo.health <= 0 || mo.bDormant) { continue; }
			if (mo.alpha < 0.25) { continue; }
			if (Distance3d(mo) > 512) { continue; }
			if (closest && Distance3d(mo) > Distance3d(closest)) { continue; }

			closest = mo;
		}

		Finder = ThinkerIterator.Create("TOSOrbit");
		while ( (mo = TOSOrbit(Finder.Next())) )
		{
			if (Distance3d(mo) > 512) { continue; }
			if (closest && Distance3d(mo) > Distance3d(closest)) { continue; }

			closest = mo;
		}

		Finder = ThinkerIterator.Create("TOSSun");
		while ( (mo = TOSSun(Finder.Next())) )
		{
			if (Distance3d(mo) > 512) { continue; }
			if (closest && Distance3d(mo) > Distance3d(closest)) { continue; }

			closest = mo;
		}

		Finder = ThinkerIterator.Create("PhotonGrenade");
		while ( (mo = PhotonGrenade(Finder.Next())) )
		{
			if (mo.target == self) { continue; }
			if (mo.tracer != self) { continue; }
			if (mo.alpha < 0.25) { continue; }

			closest = mo;
		}

		return closest;
	}

	bool A_ChangeToCloserTarget(double range = 4096, double fov = 360)
	{
		Actor old_target = target;

		ThinkerIterator EnemyFinder = ThinkerIterator.Create("TrekEnemyFlier");
		Actor mo;

		while ( (mo = TrekEnemyFlier(EnemyFinder.Next())) )
		{
			if (mo == self || mo.health <= 0 || mo.bDormant) { continue; }
			if (mo.bFriendly == bFriendly) { continue; }
			if (mo.species == species) { continue; }
			if (mo.bInvisible) { continue; }
			if (mo.alpha < 0.25) { continue; }
			if (Distance3d(mo) > range) { continue; }
			if (target && Distance3d(mo) > Distance3d(target)) { continue; }
			if (fov && absangle(AngleTo(mo), angle) > (fov / 2)) { continue; }

			if (Random[ChangeTarget]() > 128) { target = mo; }
			else { nexttarget = mo; }
		}

		if (!bFriendly) //Check for players if not friendly...
		{
			for (int i = 0; i < MAXPLAYERS; i++)
			{
				PlayerPawn mo = players[i].mo;
				if (playeringame[i] && mo)
				{
					if (players[i].cheats & CF_NOTARGET) { continue; }
					if (mo.alpha < 0.25) { continue; }
					if (Distance3d(mo) > range) { continue; }
					if (target && Distance3d(mo) > Distance3d(target)) { continue; }
					if (fov && absangle(AngleTo(mo), angle) > (fov / 2)) { continue; }

					target = mo;
				}
			}
		}

		if (target == old_target) { target = nexttarget; return False; }
		return True;
	}

	void A_DamageSigns(bool shield = True, double zoffset = 0, double xoffset = -4.0)
	{
		bool sp;
		Actor mo;
		if (shield && health > SpawnHealth() / 3) { //Shield flare
			A_SpawnItemEx("ShieldShell", xoffset, 0, zoffset, flags:SXF_TRANSFERSCALE | SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_SETMASTER);
		} else { //Damage/Explosions
			[sp, mo] = A_SpawnItemEx("FlareUp", 0, 0, 0, flags:SXF_TRANSFERSCALE | SXF_TRANSFERPITCH | SXF_TRANSFERROLL);
			mo.Scale.X = 0.01;
			mo.Scale.Y = 0.01;

			double bounce = 2500 / mass;

			angle += FRandom(-bounce, bounce);
			pitch += FRandom(-bounce, bounce);
			roll += FRandom(-bounce, bounce);

			A_PlaySound("effects/explosion", CHAN_AUTO, 1.0);
		}

		Passive = False;
	}

	void A_ShipLookChase(double dist = 256, double fov = 25.0)
	{
		int collisiondistance;

		Actor closest = A_ClosestActor();

		if (old_angle) { anglediff = angle - old_angle; }
		else
		{
			A_ChangeToCloserTarget();
			anglediff = 0;
		}

		old_angle = angle;

		if (anglediff > 180) { anglediff -= 360; }
		else if (anglediff < -180) { anglediff += 360; }

		if (anglediff > 0 && anglediff < 1) { anglediff = 1; }
		else if (anglediff < 0 && anglediff > -1) { anglediff = -1; }
		
		if (roll >= 1) { roll -= 0.5; } 
		else if (roll <= -1) { roll += 0.5; }

		if (pitch >= 1) { pitch -= 0.5; } 
		else if (pitch <= -1) { pitch += 0.5; }

		if (closest)
		{
			collisiondistance = int((height / 2 > radius ? height / 2 : radius) * sqrt(2) + (closest.height / 2 > closest.radius ? closest.height / 2 : closest.radius) * sqrt(2));
			if (closest is "PhotonGrenade") { collisiondistance = 2048.0; }
		}

		if (lastDamageSource && Random[DamageReact]() < 32)
		{
			if (lastDamageSource.bFriendly != bFriendly && lastDamageSource.species != species)
			{
				nexttarget = target;
				target = lastDamageSource;
				lastDamageSource = null;
			}
		}

		if (!target) { target = nexttarget; nexttarget = null; }

		if (closest && Distance3d(closest) <= collisiondistance * 3) // Collision avoidance
		{
			if (closest.tracer != self && Distance3d(closest) <= collisiondistance)
			{
				A_Explode(32);
				A_DamageSigns();
			}

			if (dodgetime <= 0)
			{
				if (closest.tracer == self)
				{
					nexttarget = target;
					target = closest.target;
					A_CallHelp();
					target = closest;
					bDoFire = True;
				}

				if (closest.pos.z > pos.z) { floatdir = -1; destz = Max(pos.z - 2 * height, floorz + height); }
				else if (closest.pos.z < pos.z) { floatdir = 1; destz = Min(pos.z + 2 * height, ceilingz - height); }
				else
				{
					if (closest.pos.x > pos.x) { floatdir = -1; destz = Max(pos.z - height, floorz + height); }
					else { floatdir = 1; destz = Min(pos.z + height, ceilingz - height); }
				}

				if (destz <= floorz + height || destz >= ceilingz - height) { destz = (ceilingz - floorz) / 2; floatdir *= -1; }

				destangle = (angle + (RandomPick[ShipCollisionAvoidance](-1, 1) * Random[ShipCollisionAvoidance](70, 110))) % 360;

				dodgetime = Random[DodgingTime](35, 105);
			}
		}
		else if (target && pos != old_pos && !passive)
		{
			if (Distance3d(target) < dist * (longrun + 1) ||
				closest && Distance3d(target) < dist)
			{
				if (!bRun)
				{
					destangle = angle + Random[ShipAngle](-150, 150);

					destz = Min(Max(FRandom[ShipZ](pos.z - 64.0, pos.z + 64.0), floorz + height), ceilingz - height);
					longrun = FRandom[ShipRun](0.0, 3.0);

					bRun = True;
				}
				else
				{
					if (destz > pos.z + 1) { floatdir = 1; }
					else if (destz < pos.z - 1) { floatdir = -1; }
					else { floatdir = 0; }

					if (hascloak) { if (alpha > 0) { A_SetRenderStyle(alpha - 0.005, STYLE_Translucent); } }
					else { bDoFire = True; }
				}
			}
			else
			{
				bRun = False;

				A_FaceTarget(1, 1, 0, 0, FAF_TOP);

				if (target.pos.z > pos.z + 1) { floatdir = 1; }
				else if (target.pos.z < pos.z - 1) { floatdir = -1; }
				else { floatdir = 0; }

				if (hascloak && alpha < 1.0) { alpha += 0.005; }
				else if (health > 0) { A_SetRenderStyle(1.0, STYLE_Normal); bDoFire = True; }
			}

			if (target.health <= 0 || target.bInvisible || target.alpha <= FRandom[CloakFlicker](0, 0.5)) { A_ChangeToCloserTarget(fov:fov); }
		}
		else
		{
			if (pos == old_pos && runtime > 0) // && !bRun)
			{
				destangle = angle + 180;

				destz = Min(Max(FRandom[ShipZ](pos.z - 64.0, pos.z + 64.0), floorz + height), ceilingz - height);
				runtime = int(dist * 3);
				bRun = True;
			}

			if (!bRun)
			{
				destangle = angle + Random[ShipAngle](-150, 150);

				destz = Min(Max(FRandom[ShipZ](pos.z - 64.0, pos.z + 64.0), floorz + height), ceilingz - height);
				runtime = int(dist * FRandom[ShipRun](0.0, 3.0));
				bRun = True;
			}
			else
			{
				if (hascloak) { if (alpha > 0) {A_SetRenderStyle(alpha - 0.005, STYLE_Translucent); } }	

				if (destz > pos.z + 1) { floatdir = 1; }
				else if (destz < pos.z - 1) { floatdir = -1; }
				else { floatdir = 0; }

				floatdir = 0;

				if (runtime <= 0)
				{
					bRun = False;
					runtime = 0;
					A_ChangeToCloserTarget(fov:fov);
				}
				else
				{
					runtime--;
					A_ChangeToCloserTarget(fov:fov);
				}
			}
			if (!target) { bDoFire = False; }
		}

		if (target && Distance3d(target) < 1024 && abs(roll - anglediff) < 90) { roll -= anglediff; }

		if (destangle > angle + 1) { angle += 0.5; }
		else if (destangle < angle - 1) { angle -= 0.5; }

		if (abs(pitch) < 45) { pitch += floatdir; }

		old_pos = pos;

		A_ChangeVelocity(speed, 0, floatdir, CVF_RELATIVE | CVF_REPLACE);
		A_PlaySound("ship/hum", CHAN_AUTO, 5.0);

		if (timeout) { timeout--; }
		if (dodgetime) { dodgetime--; }

		if (bDoFire && target && target.health > 0) //Lets the ship fire while moving smoothly
		{
			if (timeout <= 0 && abs(angleto(target) - angle) < fov / 2) //'timeout' tics between firing, 'fov' degrees of firing range left/right
			{
				if (health <= 0) return;
				if (A_CheckLOF("null", CLOFF_SKIPENEMY, 2048, 0, 0, 0, 0, 0, AAPTR_TARGET))
				{
					SetStateLabel("Missile");
				}
			}
		}
		else { continuousfirethreshold = 0; }

		if (passive) { target = null; }
	}
}