class TrekEnemy : Actor //For common inheritance of action functions
{
	int user_Ammo;
	int user_FireCount;
	bool hascloak;
}

extend class TrekEnemy
{
	double old_angle;
	double old_pitch;
	double old_roll;

	void A_FireDisruptor(int variance = 1, int ammoamt = 1, double zoffset = 60)
	{
		old_pitch = pitch;
		old_roll = roll;
		A_SpawnProjectile("DisruptorBolt", zoffset, 0, Random[Disruptor](-variance, variance), CMF_OFFSETPITCH | CMF_SAVEPITCH | CMF_BADPITCH, Random[Disruptor](-variance, variance), AAPTR_TARGET);
		user_ammo -= ammoamt;
		angle = old_angle;
		pitch = old_pitch;
		roll = old_roll;
	}

	void A_FireDisruptorGrenade(int variance = 5, int ammoamt = 10)
	{
		bNoRadiusDmg = True;
		A_SpawnProjectile("DisruptorGrenade", 60, 0, Random[Disruptor](-variance, variance), CMF_OFFSETPITCH | CMF_SAVEPITCH | CMF_BADPITCH, FRandom[Disruptor](variance, 15 * (GetZAt(0, 0, 0, GZF_CEILING) / 128.0)), AAPTR_TARGET);
		user_ammo -= ammoamt;
	}

	void A_FirePhaser(class<Actor> beam, class<Actor> light, class<Actor> hitpuff, int damage = 10, int ammoamt = 1, sound snd = "weapons/phaser", int xoffset = 14, double zoffset = 50)
	{
		old_pitch = pitch;
		old_roll = roll;
		A_PlaySound(snd, 0, 1.0);
		user_ammo -= ammoamt;
		A_CustomRailgun(damage, xoffset, "", "", RGF_CENTERZ | RGF_NOPIERCING | RGF_FULLBRIGHT |  RGF_SILENT, 1, 0, hitpuff, 0, 0, 2048, 4, 1.0, 0, beam, zoffset);
		A_CustomRailgun(0, xoffset, "", "", RGF_CENTERZ | RGF_NOPIERCING | RGF_FULLBRIGHT | RGF_SILENT, 1, 0, "", 0, 0, 2048, 1, FRandom(6.0, 8.0), 0, light, zoffset);
		angle = old_angle;
		pitch = old_pitch;
		roll = old_roll;
	}

	void A_FireTorpedo(class<Actor> torpedo, int ammoamt = 1, double zoffset = 60)
	{
		old_pitch = pitch;
		old_roll = roll;
		A_SpawnProjectile(torpedo, zoffset, 0, Random[Torpedo](-1, 1), CMF_OFFSETPITCH | CMF_SAVEPITCH | CMF_BADPITCH, Random[Torpedo](-1, 1), AAPTR_TARGET);
		user_ammo -= ammoamt;
		angle = old_angle;
		pitch = old_pitch;
		roll = old_roll;
	}
}

class TrekEnemyActor : TrekEnemy
{
	int user_Health;
	int user_State;
	int user_Width;
	int user_Height;
	int user_Uses;
	int user_Stunned;
	int user_Weapon;
	double user_Angle;
	double user_Pitch;
	double user_Speed;

	Default
	{
		MONSTER;
		+FLOORCLIP;
		+NOTARGET;
		Health 75;
		Speed 6;
		Radius 10;
		Height 70;
		YScale 1.33;
		DeathHeight 0;
		Mass 100;
		Painchance 128;
		BloodColor "FF 00 00";
		DamageFactor "Trek", 0.0;
		Species "Enemy";
		Activation THINGSPEC_NoDeathSpecial;
		Obituary "%o was killed by an ill-defined replacement actor.";
		YScale 1.33;
	}

	States
	{
		Spawn:
			"####" A 0 NoDelay {
				ACS_NamedExecuteAlways("SetRadarTID",0);
				ACS_NamedExecuteAlways("A_SetupThing",0);

				if (user_Speed < 0) {
					Speed = 0;
				}
				user_Speed = Speed;

				user_ammo = Random[EnemyAmmo](0, 30);
			}
			"####" # 0 A_Jump(256, "Stand");
		Stand:
			"####" A 0 {
				user_State = 2;
				if (speed == 0) {
					return ResolveState("CrouchLook");
				}
				return ResolveState(null);
			}
		Stand.Loop:
			"####" # 1 A_LookEx (0, 0, 0, 2048, 0, "Chase");
			Loop;
		CheckSight:
			"####" # 0 A_CheckLOF("Missile.Shoot", CLOFF_SKIPOBSTACLES);
			"####" A 0 {
				return ResolveState("Return");
			}
		Wander:
			"####" # 0 {
				bNoRadiusDmg = False;
				user_State = 1;
				if (user_Speed == 0) {
					return ResolveState("Crouch");
				} else {
					Speed = user_speed;
					return ResolveState(null);
				}
			}
			"####" AAAAA 1 A_Chase (null, null);
			"####" AA 1;
			"####" BBBB 1 A_Chase (null, null);
			"####" CCCCC 1 A_Chase (null, null);
			"####" CC 1;
			"####" DDDD 1 A_Chase (null, null);
		Chase:
			"####" A 0 {
				ACS_NamedExecuteAlways("A_CheckFrightened");
				user_State = 1;
				if (waterlevel > 1) {
					bFloat = True;
					Speed /= 2;
					bNoGravity = True;
				} else {
					bFloat = False;
					bNoGravity = False;

					If (Speed == 0) {
						return ResolveState("Crouch");
					}

					Speed == user_Speed;
				}
				return ResolveState(null);
			}
			"####" AAAAA 1 A_Chase("CheckSight", "CheckSight");
			"####" AA 1;
			"####" BBBB 1 A_Chase("CheckSight", "CheckSight");
			"####" CCCCC 1 A_Chase("CheckSight", "CheckSight");
			"####" CC 1;
			"####" DDDD 1 A_Chase("CheckSight", "CheckSight");
			"####" # 0 {
				if (bFrightened)
				{
					return ResolveState("Frightened");
				}
				return ResolveState(null);
			}
			Loop;
		CrouchLook:
			"####" X 1 A_LookEx (0, 0, 0, 2048, 0, "Crouch");
			Loop;
		Crouch:
			"####" # 0 {
				if (user_Speed > 0 && A_CheckLOF("Return.Speed", CLOFF_FROMBASE, 0, 0, 0, 0, 24.0)) {
					return ResolveState("Return.Speed");
				} else {
					return ResolveState(null);
				}
			}
			"####" VVVWWW 1;
			"####" XXX 1 {
				Height = Height / 2;
				A_FaceTarget();
				A_SetTics(Random[Crouch](5, 52));
				bNoRadiusDmg = False;
				if (user_Ammo < 30) {
					user_Ammo += 10;
				}
			}
			"####" XW 1 {
				if (user_Speed > 0) {
					A_Chase(null, null, CHF_FASTCHASE);
				}
			}
			"####" X 35 {
				A_FaceTarget();
				A_SetTics(Random(35, 105));
			}
			"####" WWWVVV 1;
			"####" V 1 {
				A_SetTics(Random[Popup](5, 15));
				Height = Height * 2;
			}
			Goto CheckSight;
		Melee:
		Missile:
			"####" EE 3 {
				A_FaceTarget();
				if (waterlevel > 1) {
					return ResolveState("Chase");
				} else {
					return ResolveState(null);
				}
			}
		Missile.Shoot:
			"####" # 0 {
				Speed == user_Speed;

				if (user_ammo <= 0) {
					return ResolveState("Chase");
				}

				if (user_Weapon == 1) {
					if (GetDistance(TRUE) >= 256.0) {
						return ResolveState("Fire.Grenade");
					} else {
						return ResolveState("Fire");
					}
				} else if (user_Weapon == 2) {
					return ResolveState("Fire.Rifle");
				} else if (user_Weapon == 3) {
					return ResolveState("Fire.Phaser");
				} else {
					return ResolveState("Fire");
				}
			}
			"####" A 0 A_Jump(256, "Return");
		Fire:
			"####" # 0 A_JumpIf(user_FireCount > 3, "Return");
			"####" F 1 A_FireDisruptor();
			"####" EE 3 A_FaceTarget();
			"####" F 1 A_FireDisruptor(2);
			"####" EE 3 A_FaceTarget();
			"####" F 1 A_FireDisruptor();
			"####" EE 8 A_FaceTarget();
			"####" # 0 { user_FireCount++; }
			"####" # 0 A_JumpIfHealthLower(2, "Disintegrate",  AAPTR_TARGET);
			"####" A 0 A_Jump(128, "CheckSight");
			Goto Chase;
		Fire.Grenade:
			"####" # 0 A_Jump(128, "Fire");
			"####" F 1 A_FireDisruptorGrenade();
			"####" EE 3 A_FaceTarget();
			"####" A 0 A_Jump(256, "Wander");
		Fire.Rifle:
			"####" F 0 A_JumpIf(user_FireCount > 40, "Return");
			"####" F 1 A_FirePhaser("LaserBeam_P", "SmallPurpleLight", "PhaserHitW", 12, 2, "weapons/rifle");
			"####" A 0 A_Jump(256, "CheckSight");
		Fire.Phaser:
			"####" A 0 A_JumpIf(user_FireCount > 10, "Return");
			"####" F 1 A_FirePhaser("LaserBeam_R", "SmallRedLight", "PhaserDisintegrateHit");
			"####" A 0 A_Jump(256, "CheckSight");
		Return:
			"####" # 0 {
				A_StopSound(CHAN_WEAPON);
				user_FireCount = 0;
				if (user_ammo <= 0) {
					bFrightened = True;
				}
			}
			"####" # 0 A_CheckLOF("Return.Speed", CLOFF_FROMBASE, 0, 0, 0, 0, 24.0);
			"####" # 0 {
				if (Random(0, 256) < 128) {
					Speed = 0;
				} else {
					Speed = user_Speed;
				}
			}
			Goto Chase;
		Return.Speed:
			"####" # 0 {
				Speed = user_Speed;
			}
			Goto Chase;
		Pain:
			"####" G 3;
			"####" G 3 A_Pain;
			Goto Wander;
		Death:
			"####" H 5 {
				A_StopSound(CHAN_WEAPON); //Just in case
				A_CallSpecial(special, args[0], args[1], args[2], args[3], args[4]);
				A_NoBlocking();
			}
			"####" I 5 {
				A_Scream();
				if (user_Weapon == 2) {
					A_DropItem("PhaserRifle", user_ammo);
				} else if (user_Weapon == 3) {
					A_DropItem("PhaserType2", user_ammo);
				} else {
					A_DropItem("Disruptor", user_ammo);
				}
			}
			"####" JK 5;
			"####" L -1;
			Stop;
		Death.Stun:
			"####" H 5 {
				A_UnSetSolid();
				bShootable = False;
				A_StopSound(CHAN_WEAPON); //Just in case
			}
			"####" I 5 A_Scream();
			"####" JK 5;
			"####" L -1;
			Stop;
		XDeath:
			"####" M 5 {
				A_StopSound(CHAN_WEAPON); //Just in case
				A_CallSpecial(special, args[0], args[1], args[2], args[3], args[4]);
				A_NoBlocking();
			}
			"####" N 5 A_XScream;
			"####" OPQRST 5;
			"####" U -1;
			Stop;
		Raise:
			"####" K 5 {
				A_SetSolid();
				bShootable = True;
			}
			"####" JIH 5;
			Goto Chase;
		Disintegrate:
			"####" # 0 A_GiveInventory("Disintegration", 1, AAPTR_TARGET);
			"####" # 0 A_ClearTarget;
			Goto Wander;
		Frightened:
			"####" A 0 {
				if (user_ammo < 30)
				{
					user_Ammo += 5;
				}
			}
			"####" A 0 A_Jump(256, "Chase");
	}
}

class TrekEnemyFlier : TrekEnemy
{
	bool bDoFire;
	int timeout;
	int continuousfirethreshold;

	Default
	{
		MONSTER
		+NOGRAVITY;
		+NOBLOOD;
		YScale 1.0;
		Painchance 256; //Really just for how often the shield flare/damage shows up.
		Height 32;
		Radius 32;
		Speed 1;
		Health 1000;
	}

	States
	{
		Spawn:
			TOS1 A 1;
			"####" # 0 {
				return ResolveState("Stand");
			}
		Stand:
			"####" # 1 {
				ACS_NamedExecuteAlways("SetRadarTID",0);
				ACS_NamedExecuteAlways("A_SetupThing",0);
				bDoFire = False;
				bNoGravity = True; //Just in case?
			}
			"####" # Random(0, 35);
			"####" # 1 {
				return ResolveState("Chase");
			}
		Chase:
			"####" # 1 {
				A_ShipLookChase();
			}
			Loop;
		Missile:
		Missile.Disruptor:
			"####" # 10;
			"####" # 0 {
				if (user_FireCount > 3) {
					timeout = 70;
					user_FireCount = 0;
				} else {
					A_FireDisruptor(0, zoffset:16);
					timeout = 10;
					user_FireCount++;
				}
				return ResolveState("Chase");
			}
		Missile.Phaser:
			"####" # 1;
			"####" # 0 { 
				if (!continuousfirethreshold) { continuousfirethreshold = Random[ShipFire](35, 105); }
				if (user_FireCount > continuousfirethreshold || GetDistance(target) > 2048) {
					timeout = 70;
					continuousfirethreshold = 0;
					user_FireCount = 0;
					return ResolveState("Chase");
				}
				A_FirePhaser("LaserBeam_B", "SmallBlueLight", "PhaserHit", 1, xoffset: 0, zoffset:-2);
				A_FaceTarget(1, 1, 0, 0, FAF_TOP);
				user_FireCount++;
				return ResolveState("Chase");
			}
		Missile.Torpedo:
			"####" # 1;
			"####" # 0 {
				A_FireTorpedo("PhotonTorpedo", zoffset:16);
				timeout = 70;
				return ResolveState("Chase");
			}
		Missile.RomulanTorpedo:
			"####" # 1;
			"####" # 0 {
				A_FireTorpedo("RomulanTorpedo", zoffset:16);
				timeout = 350;
				return ResolveState("Chase");
			}
		Pain:
			"####" # 1; 
			"####" # 0 {
				A_CallHelp(maxhelp:1);
				A_DamageSigns();
				return ResolveState("Chase");
			}
		Death:
		XDeath:
			"####" # 45 {
				A_Scream();
				bNoGravity = True;
				ACS_NamedExecuteAlways("A_Disintegrate", 0, 16743936, 1);
				A_SetScale(0.5);
				A_SpawnItemEx("FlareUp", flags:SXF_TRANSFERSCALE);
				A_SetScale(1.25);
				A_SetPitch(pitch + FRandom(-30.0, 30.0), SPF_INTERPOLATE);
				A_SetRoll(roll + FRandom(-30.0, 30.0), SPF_INTERPOLATE);
			}
			Stop;
	}
}

extend class TrekEnemyFlier
{
	vector3 old_pos;
	double anglediff;
	double old_z;
	double destangle;
	double destz;
	double longrun;
	int floatdir;
	int bursttimeout;
	int runtime;
	bool bRun;
	bool attacked;

	void A_CallHelp(double range = 1024, int maxhelp = 3)
	{
		int helpercount;

		ThinkerIterator FriendFinder = ThinkerIterator.Create("TrekEnemyFlier");
		Actor mo;
		while ( (mo = TrekEnemyFlier(FriendFinder.Next())) )
		{
			if (helpercount > maxhelp) { continue; }
			if (mo == self || mo.health <= 0 || mo.target || mo.bDormant) { continue; }
			if (mo.bFriendly != bFriendly) { continue; }
			if (Distance3d(mo) > range) { continue; }

			mo.target = target;
			helpercount++;
		}
	}

	actor A_ClosestActor(void)
	{
		ThinkerIterator Finder = ThinkerIterator.Create("TrekEnemyFlier");
		Actor mo, closest;
		while ( (mo = TrekEnemyFlier(Finder.Next())) )
		{
			if (mo == self || mo.health <= 0 || mo.bDormant) { continue; }
			if (mo.alpha < 0.5) { continue; }
			if (Distance3d(mo) > 512) { continue; }
			if (closest && Distance3d(mo) > Distance3d(closest)) { continue; }

			closest = mo;
		}

		Finder = ThinkerIterator.Create("TOSOrbit");
		while ( (mo = TOSOrbit(Finder.Next())) )
		{
			if (Distance3d(mo) > 512) { continue; }
			if (closest && Distance3d(mo) > Distance3d(closest)) { continue; }

			closest = mo;
		}

		Finder = ThinkerIterator.Create("TOSSun");
		while ( (mo = TOSSun(Finder.Next())) )
		{
			if (Distance3d(mo) > 512) { continue; }
			if (closest && Distance3d(mo) > Distance3d(closest)) { continue; }

			closest = mo;
		}

		Finder = ThinkerIterator.Create("PhotonGrenade");
		while ( (mo = PhotonGrenade(Finder.Next())) )
		{
			if (mo.tracer != self) { continue; }
			if (mo.alpha < 0.5) { continue; }
//			if (closest && Distance3d(mo) > Distance3d(closest)) { continue; }

			closest = mo;
		}

		return closest;
	}

	bool A_ChangeToCloserTarget(double range = 4096, double fov = 0)
	{
		Actor old_target = target;
		ThinkerIterator EnemyFinder = ThinkerIterator.Create("TrekEnemyFlier");
		Actor mo;
		while ( (mo = TrekEnemyFlier(EnemyFinder.Next())) )
		{
			if (mo == self || mo.health <= 0 || mo.bDormant) { continue; }
			if (mo.bFriendly == bFriendly) { continue; }
			if (mo.alpha < 0.5) { continue; }
			if (mo.bInvisible) { continue; }
			if (Distance3d(mo) > range) { continue; }
			if (target && Distance3d(mo) > Distance3d(target)) { continue; }
			if (fov && absangle(AngleTo(mo), angle) > (fov / 2)) { continue; }

			target = mo;
		}

		if (!bFriendly) //Check, for players if not friendly...
		{
			for (int i = 0; i < MAXPLAYERS; i++)
			{
				PlayerPawn mo = players[i].mo;
				if (playeringame[i] && mo)
				{
					if (players[i].cheats & CF_NOTARGET) { continue; }
					if (mo.alpha < 0.5) { continue; }
					if (Distance3d(mo) > range) { continue; }
					if (target && Distance3d(mo) > Distance3d(target)) { continue; }
					if (fov && absangle(AngleTo(mo), angle) > (fov / 2)) { continue; }

					target = mo;
				}
			}
		}

		if (target == old_target) { target = NULL; return False; }

		return True;
	}

	void A_DamageSigns(bool shield = True)
	{
		bool sp;
		Actor mo;
		if (shield && health > SpawnHealth() / 3) { //Shield flare
//			[sp, mo] = A_SpawnItemEx("ExplosionSphereWhite", 0, 0, 0, flags:SXF_TRANSFERSCALE | SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_SETMASTER);
//			mo.alpha = 0.1;
//			mo.Scale.X = 50 / radius;
//			mo.Scale.Y = height / 30;
			A_SpawnItemEx("ShieldShell", 0, 0, 0, flags:SXF_TRANSFERSCALE | SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_SETMASTER);
		} else { //Damage/Explosions
			[sp, mo] = A_SpawnItemEx("FlareUp", 0, 0, 0, flags:SXF_TRANSFERSCALE | SXF_TRANSFERPITCH | SXF_TRANSFERROLL);
			mo.Scale.X = 0.01;
			mo.Scale.Y = 0.01;
		}

		angle += Random(-5, 5);
		pitch += Random(-5, 5);
		roll += Random(-5, 5);
	}

	void A_ShipLookChase(double dist = 256, double fov = 25.0)
	{
		int collisiondistance;

		Actor closest = A_ClosestActor();

		if (old_angle) { anglediff = angle - old_angle; }
		else
		{
			A_ChangeToCloserTarget();
			anglediff = 0;
		}

		old_angle = angle;
		
		if (anglediff > 180) { anglediff -= 360; }
		else if (anglediff < -180) { anglediff += 360; }

		if (abs(roll - anglediff) < 90) { roll -= anglediff; }

		if (roll >= 1) { roll -= 0.5; } 
		else if (roll <= -1) { roll += 0.5; }

		if (pitch >= 1) { pitch -= 0.5; } 
		else if (pitch <= -1) { pitch += 0.5; }

		if (closest)
		{
			collisiondistance = int((height / 2 > radius ? height / 2 : radius) * sqrt(2) + (closest.height / 2 > closest.radius ? closest.height / 2 : closest.radius) * sqrt(2));
			if (closest is "PhotonGrenade") { collisiondistance = 512.0; }
		}

		if (closest && Distance3d(closest) <= collisiondistance * 2) // Collision avoidance
		{
			if (closest.tracer != self && Distance3d(closest) <= collisiondistance)
			{
				A_Explode(32);
				A_DamageSigns();
			}

			if (closest.pos.z > pos.z) { floatdir = -1; destz = Max(pos.z - height, floorz + height); }
			else if (closest.pos.z < pos.z) { floatdir = 1; destz = Min(pos.z + height, ceilingz - height); }
			else
			{
				if (closest.pos.x > pos.x) { floatdir = -1; destz = Max(pos.z - height, floorz + height); }
				else { floatdir = 1; destz = Min(pos.z + height, ceilingz - height); }
			}

			if (destz == floorz + height || destz == ceilingz - height) { destz = (ceilingz - floorz) / 2; floatdir *= -1; }

			destangle = angle + Random[ShipCollisionAvoidance](30, 90);
			bRun = True;
		}
		else if (target && pos != old_pos)
		{
			if (Distance3d(target) < dist * (longrun + 1) ||
				closest && Distance3d(target) < dist)
			{
				if (!bRun)
				{
					destangle = angle + 180 + Random[ShipAngle](-30, 30) % 360;
					destz = Min(Max(FRandom[ShipZ](pos.z - 64.0, pos.z + 64.0), floorz + height), ceilingz - height);
					longrun = FRandom[ShipRun](0.0, 3.0);

					bRun = True;
				}
				else
				{
					if (destangle > angle + 1) { angle += 0.5; }
					else if (destangle < angle - 1) { angle -= 0.5; }

					if (destz > pos.z + 1) { floatdir = 1; }
					else if (destz < pos.z - 1) { floatdir = -1; }
					else { floatdir = 0; }

					if (hascloak) { if (alpha > 0) { A_SetRenderStyle(alpha - 0.005, STYLE_Translucent); } }
					else { bDoFire = True; }
				}
			}
			else
			{
				bRun = False;

				A_FaceTarget(1, 1, 0, 0, FAF_TOP);

				if (target.pos.z > pos.z + 1) { floatdir = 1; }
				else if (target.pos.z < pos.z - 1) { floatdir = -1; }
				else { floatdir = 0; }

				if (hascloak && alpha < 1.0) { alpha += 0.005; }
				else if (health > 0) { A_SetRenderStyle(1.0, STYLE_Normal); bDoFire = True; }
			}

			if (target.health <= 0 || target.bInvisible || target.alpha <= FRandom[CloakFlicker](0, 0.5)) { A_ChangeToCloserTarget(); }
		}
		else
		{
			if (pos == old_pos && runtime > 0 && !bRun)
			{
				destangle = angle + 180 % 360;
				destz = Min(Max(FRandom[ShipZ](pos.z - 64.0, pos.z + 64.0), floorz + height), ceilingz - height);
				runtime = int(dist * 3);
				bRun = True;
			}
			else if (!bRun)
			{
				destangle = angle + 180 + Random[ShipAngle](-30, 30) % 360;
				destz = Min(Max(FRandom[ShipZ](pos.z - 64.0, pos.z + 64.0), floorz + height), ceilingz - height);
				runtime = int(dist * FRandom[ShipRun](0.0, 3.0));
				bRun = True;
			}
			else
			{
				if (hascloak) { if (alpha > 0) {A_SetRenderStyle(alpha - 0.005, STYLE_Translucent); } }	

				if (destangle > angle + 1) { angle += 0.5; }
				else if (destangle < angle - 1) { angle -= 0.5; }
/*
				if (destz > pos.z + 1) { floatdir = 1; }
				else if (destz < pos.z - 1) { floatdir = -1; }
				else { floatdir = 0; }
*/
				floatdir = 0;

				if (runtime <= 0)
				{
					bRun = False;
					runtime = 0;
					A_ChangeToCloserTarget();
				}
				else
				{
					runtime--;
					A_ChangeToCloserTarget(fov:fov);
				}
			}
			if (!target) { bDoFire = False; }
		}

		if (abs(pitch) < 20) { pitch += floatdir; }

		old_pos = pos;

		A_ChangeVelocity(speed, 0, floatdir * speed / 2, CVF_RELATIVE | CVF_REPLACE);

		if (bDoFire && target && target.health > 0) //Lets the ship fire while moving smoothly
		{
			if (timeout <= 0 && abs(angleto(target) - angle) < fov) //'timeout' tics between firing, 'fov' degrees of firing range left/right
			{
				if (health <= 0) return;
				if (A_CheckLOF("null", CLOFF_SKIPENEMY | CLOFF_SKIPOBJECT, 2048, 0, 0, 0, 0, 0, AAPTR_TARGET)) { SetStateLabel("Missile"); }
			}
		}
		else { continuousfirethreshold = 0; }
		timeout--;
		A_PlaySound("ship/hum", CHAN_AUTO, 5.0);
	}

	bool CheckinFOV(int fov = 80)
	{
		if (!target) { return false; }

		double an = absangle(AngleTo(target), angle);

		if (an > (fov / 2))
		{
			return False;
		}
		return True;
	}
}